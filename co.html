
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>bramble: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/maxmcd/bramble/main.go (0.0%)</option>
				
				<option value="file1">github.com/maxmcd/bramble/pkg/assert/assert.go (14.3%)</option>
				
				<option value="file2">github.com/maxmcd/bramble/pkg/bramble/bramble.go (61.3%)</option>
				
				<option value="file3">github.com/maxmcd/bramble/pkg/bramble/bramble_derivation.go (86.0%)</option>
				
				<option value="file4">github.com/maxmcd/bramble/pkg/bramble/cli.go (0.0%)</option>
				
				<option value="file5">github.com/maxmcd/bramble/pkg/bramble/config.go (76.7%)</option>
				
				<option value="file6">github.com/maxmcd/bramble/pkg/bramble/data_structures.go (68.0%)</option>
				
				<option value="file7">github.com/maxmcd/bramble/pkg/bramble/derivation.go (81.8%)</option>
				
				<option value="file8">github.com/maxmcd/bramble/pkg/bramble/docker.go (0.0%)</option>
				
				<option value="file9">github.com/maxmcd/bramble/pkg/bramble/errors.go (0.0%)</option>
				
				<option value="file10">github.com/maxmcd/bramble/pkg/bramble/files_builtin.go (67.4%)</option>
				
				<option value="file11">github.com/maxmcd/bramble/pkg/cmd/bramble-setuid/main.go (0.0%)</option>
				
				<option value="file12">github.com/maxmcd/bramble/pkg/cmd/progressui/main.go (0.0%)</option>
				
				<option value="file13">github.com/maxmcd/bramble/pkg/cmd/reptar/main.go (0.0%)</option>
				
				<option value="file14">github.com/maxmcd/bramble/pkg/fileutil/fileutil.go (47.1%)</option>
				
				<option value="file15">github.com/maxmcd/bramble/pkg/hasher/hasher.go (72.2%)</option>
				
				<option value="file16">github.com/maxmcd/bramble/pkg/logger/logger.go (52.3%)</option>
				
				<option value="file17">github.com/maxmcd/bramble/pkg/progressui/display.go (0.0%)</option>
				
				<option value="file18">github.com/maxmcd/bramble/pkg/progressui/printer.go (0.0%)</option>
				
				<option value="file19">github.com/maxmcd/bramble/pkg/reptar/reptar.go (77.3%)</option>
				
				<option value="file20">github.com/maxmcd/bramble/pkg/sandbox/chrootenv.go (0.0%)</option>
				
				<option value="file21">github.com/maxmcd/bramble/pkg/sandbox/sandbox.go (0.0%)</option>
				
				<option value="file22">github.com/maxmcd/bramble/pkg/starutil/conversions.go (78.9%)</option>
				
				<option value="file23">github.com/maxmcd/bramble/pkg/starutil/errors.go (0.0%)</option>
				
				<option value="file24">github.com/maxmcd/bramble/pkg/store/store.go (69.6%)</option>
				
				<option value="file25">github.com/maxmcd/bramble/pkg/textreplace/textreplace.go (57.1%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import "github.com/maxmcd/bramble/pkg/bramble"

func main() <span class="cov0" title="0">{
        bramble.RunCLI()
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package assert

import (
        "fmt"
        "regexp"
        "sync"

        "go.starlark.net/starlark"
        "go.starlark.net/starlarkstruct"
)

var assertModule = `# Predeclared built-ins for this module:
#
# error(msg): report an error in Go's test framework without halting execution.
#  This is distinct from the built-in fail function, which halts execution.
# catch(f): evaluate f() and returns its evaluation error message, if any
# matches(str, pattern): report whether str matches regular expression pattern.
# module(**kwargs): a constructor for a module.
# _freeze(x): freeze the value x and everything reachable from it.
#
# Clients may use these functions to define their own testing abstractions.

def _eq(x, y):
    if x != y:
        error("%r != %r" % (x, y))

def _ne(x, y):
    if x == y:
        error("%r == %r" % (x, y))

def _true(cond, msg = "assertion failed"):
    if not cond:
        error(msg)

def _lt(x, y):
    if not (x &lt; y):
        error("%s is not less than %s" % (x, y))

def _contains(x, y):
    if y not in x:
        error("%s does not contain %s" % (x, y))

def _fails(f, pattern):
    "assert_fails asserts that evaluation of f() fails with the specified error."
    msg = catch(f)
    if msg == None:
        error("evaluation succeeded unexpectedly (want error matching %r)" % pattern)
    elif not matches(pattern, msg):
        error("regular expression (%s) did not match error (%s)" % (pattern, msg))

freeze = _freeze  # an exported global whose value is the built-in freeze function

assert = module(
    "assert",
    fail = error,
    eq = _eq,
    ne = _ne,
    true = _true,
    lt = _lt,
    contains = _contains,
    fails = _fails,
)`

// Copyright 2017 The Bazel Authors. All rights reserved.

const localKey = "Reporter"

// A Reporter is a value to which errors may be reported.
// It is satisfied by *testing.T.
type Reporter interface {
        Error(err error)
        FailNow() bool
}

// SetReporter associates an error reporter (such as a testing.T in
// a Go test) with the Starlark thread so that Starlark programs may
// report errors to it.
func SetReporter(thread *starlark.Thread, r Reporter) <span class="cov8" title="1">{
        thread.SetLocal(localKey, r)
}</span>

// GetReporter returns the Starlark thread's error reporter.
// It must be preceded by a call to SetReporter.
func GetReporter(thread *starlark.Thread) Reporter <span class="cov0" title="0">{
        r, ok := thread.Local(localKey).(Reporter)
        if !ok </span><span class="cov0" title="0">{
                panic("internal error: starlarktest.SetReporter was not called")</span>
        }
        <span class="cov0" title="0">return r</span>
}

var (
        once      sync.Once
        assert    starlark.StringDict
        assertErr error
)

// LoadAssertModule loads the assert module.
// It is concurrency-safe and idempotent.
func LoadAssertModule() (starlark.StringDict, error) <span class="cov8" title="1">{
        once.Do(func() </span><span class="cov8" title="1">{
                predeclared := starlark.StringDict{
                        "error":   starlark.NewBuiltin("error", Error),
                        "catch":   starlark.NewBuiltin("catch", catch),
                        "matches": starlark.NewBuiltin("matches", matches),
                        "module":  starlark.NewBuiltin("module", starlarkstruct.MakeModule),
                        "_freeze": starlark.NewBuiltin("freeze", freeze),
                }
                thread := new(starlark.Thread)
                assert, assertErr = starlark.ExecFile(thread, "assert.star", assertModule, predeclared)
        }</span>)
        <span class="cov8" title="1">return assert, assertErr</span>
}

// catch(f) evaluates f() and returns its evaluation error message
// if it failed or None if it succeeded.
func catch(thread *starlark.Thread, _ *starlark.Builtin, args starlark.Tuple, kwargs []starlark.Tuple) (starlark.Value, error) <span class="cov0" title="0">{
        var fn starlark.Callable
        if err := starlark.UnpackArgs("catch", args, kwargs, "fn", &amp;fn); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if _, err := starlark.Call(thread, fn, nil, nil); err != nil </span><span class="cov0" title="0">{
                return starlark.String(err.Error()), nil
        }</span>
        <span class="cov0" title="0">return starlark.None, nil</span>
}

// matches(pattern, str) reports whether string str matches the regular expression pattern.
func matches(thread *starlark.Thread, _ *starlark.Builtin, args starlark.Tuple, kwargs []starlark.Tuple) (starlark.Value, error) <span class="cov0" title="0">{
        var pattern, str string
        if err := starlark.UnpackArgs("matches", args, kwargs, "pattern", &amp;pattern, "str", &amp;str); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">ok, err := regexp.MatchString(pattern, str)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("matches: %s", err)
        }</span>
        <span class="cov0" title="0">return starlark.Bool(ok), nil</span>
}

// error(x) reports an error to the Go test framework.
func Error(thread *starlark.Thread, _ *starlark.Builtin, args starlark.Tuple, kwargs []starlark.Tuple) (starlark.Value, error) <span class="cov0" title="0">{
        if len(args) != 1 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error: got %d arguments, want 1", len(args))
        }</span>
        <span class="cov0" title="0">stk := thread.CallStack()
        stk.Pop()
        err := &amp;starlark.EvalError{
                CallStack: stk,
        }
        if s, ok := starlark.AsString(args[0]); ok </span><span class="cov0" title="0">{
                err.Msg = s
        }</span> else<span class="cov0" title="0"> {
                err.Msg = args[0].String()
        }</span>
        <span class="cov0" title="0">reporter := GetReporter(thread)
        reporter.Error(err)
        if reporter.FailNow() </span><span class="cov0" title="0">{
                return starlark.None, err
        }</span>
        <span class="cov0" title="0">return starlark.None, nil</span>
}

// freeze(x) freezes its operand.
func freeze(thread *starlark.Thread, _ *starlark.Builtin, args starlark.Tuple, kwargs []starlark.Tuple) (starlark.Value, error) <span class="cov0" title="0">{
        if len(kwargs) &gt; 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("freeze does not accept keyword arguments")
        }</span>
        <span class="cov0" title="0">if len(args) != 1 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("freeze got %d arguments, wants 1", len(args))
        }</span>
        <span class="cov0" title="0">args[0].Freeze()
        return args[0], nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package bramble

import (
        "bytes"
        "context"
        "crypto/tls"
        "encoding/hex"
        "encoding/json"
        "flag"
        "fmt"
        "io"
        "io/ioutil"
        "net"
        "net/http"
        "os"
        "os/exec"
        "os/user"
        "path/filepath"
        "runtime/debug"
        "runtime/trace"
        "sort"
        "strconv"
        "strings"
        "sync"
        "time"

        "github.com/certifi/gocertifi"
        git "github.com/go-git/go-git/v5"
        gitclient "github.com/go-git/go-git/v5/plumbing/transport/client"
        githttp "github.com/go-git/go-git/v5/plumbing/transport/http"
        "github.com/maxmcd/dag"
        "github.com/mholt/archiver/v3"
        "github.com/pkg/errors"
        "go.starlark.net/repl"
        "go.starlark.net/resolve"
        "go.starlark.net/starlark"

        "github.com/maxmcd/bramble/pkg/assert"
        "github.com/maxmcd/bramble/pkg/fileutil"
        "github.com/maxmcd/bramble/pkg/hasher"
        "github.com/maxmcd/bramble/pkg/logger"
        "github.com/maxmcd/bramble/pkg/reptar"
        "github.com/maxmcd/bramble/pkg/sandbox"
        "github.com/maxmcd/bramble/pkg/starutil"
        "github.com/maxmcd/bramble/pkg/store"
        "github.com/maxmcd/bramble/pkg/textreplace"
)

func init() <span class="cov8" title="1">{
        // It's easier to start giving away free coffee than it is to take away
        // free coffee.

        // I think this would allow storing arbitrary state in function closures
        // and make the codebase much harder to reason about. Maybe we want this
        // level of complexity at some point, but nice to avoid for now.
        resolve.AllowLambda = false
        resolve.AllowNestedDef = false

        // Recursion might make it easier to write long executing code.
        resolve.AllowRecursion = false

        // Sets seem harmless tho?
        resolve.AllowSet = true

        // See little need for this (currently), but open to allowing it. Are there
        // correctness issues here?
        resolve.AllowFloat = false
}</span>

var (
        BrambleExtension string = ".bramble"
)

// Bramble is the main bramble client. It has various caches and metadata
// associated with running bramble.
type Bramble struct {
        thread      *starlark.Thread
        predeclared starlark.StringDict

        // don't use features that require root like setuid binaries
        noRoot bool

        config         Config
        configLocation string
        lockFile       LockFile
        lockFileLock   sync.Mutex

        // working directory
        wd string

        derivationFn *derivationFunction

        store store.Store

        moduleCache   map[string]string
        filenameCache *BiStringMap

        derivations *DerivationsMap
}

func (b *Bramble) checkForExistingDerivation(filename string) (outputs []Output, exists bool, err error) <span class="cov8" title="1">{
        existingDrv, exists, err := b.loadDerivation(filename)
        // It doesn't exist if it doesn't exist
        if !exists </span><span class="cov8" title="1">{
                return nil, exists, nil
        }</span>
        // It doesn't exist if it doesn't have the outputs we need
        <span class="cov8" title="1">return existingDrv.Outputs, !existingDrv.MissingOutput(), err</span>
}

func (b *Bramble) storeDerivation(drv *Derivation) <span class="cov8" title="1">{
        b.derivations.Store(drv.filename(), drv)
}</span>

func (b *Bramble) buildDerivationIfNew(ctx context.Context, drv *Derivation) (didBuild bool, err error) <span class="cov8" title="1">{
        exists, err := drv.populateOutputsFromStore()
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov8" title="1">filename := drv.filename()
        logger.Debugw("buildDerivationIfNew", "derivation", filename, "exists", exists)
        if exists </span><span class="cov8" title="1">{
                return false, nil
        }</span>
        <span class="cov8" title="1">logger.Print("Building derivation", filename)
        logger.Debugw(drv.PrettyJSON())

        if err = b.buildDerivation(ctx, drv, false); err != nil </span><span class="cov0" title="0">{
                return false, errors.Wrap(err, "error building "+filename)
        }</span>
        // TODO: lock store on write
        <span class="cov8" title="1">return true, b.writeDerivation(drv)</span>
}

func (b *Bramble) hashAndMoveFetchURL(ctx context.Context, drv *Derivation, outputPath string) (err error) <span class="cov8" title="1">{
        region := trace.StartRegion(ctx, "hashAndMoveFetchUrl")
        defer region.End()

        hshr := hasher.NewHasher()
        _, err = b.archiveAndScanOutputDirectory(ctx, ioutil.Discard, hshr, drv, filepath.Base(outputPath))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">outputFolderName := hshr.String()
        drv.SetOutput("out", Output{Path: outputFolderName})
        outputStorePath := b.store.JoinStorePath(outputFolderName)
        if fileutil.PathExists(outputStorePath) </span><span class="cov0" title="0">{
                err = os.RemoveAll(outputPath)
        }</span> else<span class="cov8" title="1"> {
                err = os.Rename(outputPath, outputStorePath)
        }</span>
        <span class="cov8" title="1">if err == nil </span><span class="cov8" title="1">{
                logger.Print("Output at", outputStorePath)
        }</span>
        <span class="cov8" title="1">return</span>
}

func (b *Bramble) buildDerivation(ctx context.Context, drv *Derivation, shell bool) (err error) <span class="cov8" title="1">{
        var task *trace.Task
        ctx, task = trace.NewTask(ctx, "buildDerivation")
        defer task.End()

        buildDir, err := b.store.TempDir()
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">if drv.BuildContextSource != "" </span><span class="cov8" title="1">{
                if err = fileutil.CopyDirectory(b.store.JoinStorePath(drv.BuildContextSource), buildDir); err != nil </span><span class="cov0" title="0">{
                        err = errors.Wrap(err, "error copying sources into build dir")
                        return
                }</span>
        }
        <span class="cov8" title="1">outputPaths := map[string]string{}
        for _, name := range drv.OutputNames </span><span class="cov8" title="1">{
                // TODO: use directory within store instead so that we can rewrite self-referential paths
                if outputPaths[name], err = b.store.TempDir(); err != nil </span><span class="cov0" title="0">{
                        return
                }</span>
        }
        <span class="cov8" title="1">drvCopy, err := drv.copyWithOutputValuesReplaced()
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">if shell &amp;&amp; (drv.Builder == "fetch_url" || drv.Builder == "fetch_git") </span><span class="cov0" title="0">{
                return errors.New("can't spawn a shell with a builtin builder")
        }</span>

        <span class="cov8" title="1">switch drv.Builder </span>{
        case "fetch_url":<span class="cov8" title="1">
                err = b.fetchURLBuilder(ctx, drvCopy, outputPaths)</span>
        case "fetch_git":<span class="cov0" title="0">
                err = b.fetchGitBuilder(ctx, drvCopy, outputPaths)</span>
        default:<span class="cov8" title="1">
                err = b.regularBuilder(ctx, drvCopy, buildDir, outputPaths, shell)</span>
        }
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">if err := os.RemoveAll(buildDir); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if drv.Builder == "fetch_url" </span><span class="cov8" title="1">{
                // fetch url just hashes the directory and moves it into the output
                // location, no archiving and byte replacing
                return b.hashAndMoveFetchURL(ctx, drv, outputPaths["out"])
        }</span>
        <span class="cov8" title="1">return errors.Wrap(b.hashAndMoveBuildOutputs(ctx, drv, outputPaths), "hash and move build outputs")</span>
}

func (b *Bramble) hashAndMoveBuildOutputs(ctx context.Context, drv *Derivation, outputPaths map[string]string) (err error) <span class="cov8" title="1">{
        region := trace.StartRegion(ctx, "hashAndMoveBuildOutputs")
        defer region.End()

        for outputName, outputPath := range outputPaths </span><span class="cov8" title="1">{
                hshr := hasher.NewHasher()
                var reptarFile *os.File
                reptarFile, err = b.createTmpFile()
                if err != nil </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov8" title="1">outputFolder := filepath.Base(outputPath)
                matches, err := b.archiveAndScanOutputDirectory(ctx, reptarFile, hshr, drv, outputFolder)
                if err != nil </span><span class="cov0" title="0">{
                        return errors.Wrap(err, "error scanning output")
                }</span>
                // remove build output, we have it in an archive
                <span class="cov8" title="1">if err = os.RemoveAll(outputPath); err != nil </span><span class="cov0" title="0">{
                        return errors.Wrap(err, "error removing build output")
                }</span>

                <span class="cov8" title="1">hashedFolderName := hshr.String()

                // Nix adds the name to the output path but we are a
                // content-addressable-store so we remove so that derivations with
                // different names can share outputs
                newPath := b.store.JoinStorePath(hashedFolderName)

                if !fileutil.PathExists(newPath) </span><span class="cov8" title="1">{
                        if err := b.unarchiveAndReplaceOutputFolderName(
                                ctx,
                                reptarFile.Name(),
                                newPath,
                                outputFolder,
                                hashedFolderName); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
                <span class="cov8" title="1">if err := os.RemoveAll(reptarFile.Name()); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">drv.SetOutput(outputName, Output{Path: hashedFolderName, Dependencies: matches})
                logger.Print("Output at ", newPath)</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func (b *Bramble) unarchiveAndReplaceOutputFolderName(ctx context.Context, archive, dst, outputFolder, hashedFolderName string) (err error) <span class="cov8" title="1">{
        region := trace.StartRegion(ctx, "unarchiveAndReplaceOutputFolderName")
        defer region.End()
        pipeReader, pipWriter := io.Pipe()
        f, err := os.Open(archive)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">errChan := make(chan error)
        doneChan := make(chan struct{})

        go func() </span><span class="cov8" title="1">{
                if _, err := textreplace.ReplaceBytes(
                        f, pipWriter,
                        []byte(outputFolder), []byte(hashedFolderName)); err != nil </span><span class="cov0" title="0">{
                        errChan &lt;- err
                        return
                }</span>
                <span class="cov8" title="1">if err := pipWriter.Close(); err != nil </span><span class="cov0" title="0">{
                        errChan &lt;- err
                        return
                }</span>
        }()
        <span class="cov8" title="1">go func() </span><span class="cov8" title="1">{
                tr := archiver.NewTar()
                if err := tr.UnarchiveReader(pipeReader, archive, dst); err != nil </span><span class="cov0" title="0">{
                        errChan &lt;- err
                }</span>
                <span class="cov8" title="1">doneChan &lt;- struct{}{}</span>
        }()
        <span class="cov8" title="1">select </span>{
        case err := &lt;-errChan:<span class="cov0" title="0">
                return err</span>
        case &lt;-doneChan:<span class="cov8" title="1"></span>
        }
        <span class="cov8" title="1">return</span>
}

func (b *Bramble) archiveAndScanOutputDirectory(ctx context.Context, tarOutput, hashOutput io.Writer, drv *Derivation, storeFolder string) (
        matches []string, err error) <span class="cov8" title="1">{
        region := trace.StartRegion(ctx, "archiveAndScanOutputDirectory")
        defer region.End()
        var storeValues []string
        oldStorePath := b.store.StorePath

        for _, do := range drv.InputDerivations </span><span class="cov8" title="1">{
                storeValues = append(storeValues,
                        b.store.JoinStorePath(
                                b.derivations.Load(do.Filename).Output(do.OutputName).Path,
                        ),
                )
        }</span>

        <span class="cov8" title="1">var wg sync.WaitGroup
        wg.Add(1)

        errChan := make(chan error)
        resultChan := make(chan map[string]struct{})
        pipeReader, pipeWriter := io.Pipe()
        pipeReader2, pipeWriter2 := io.Pipe()

        // write the output files into an archive
        go func() </span><span class="cov8" title="1">{
                if err := reptar.Reptar(b.store.JoinStorePath(storeFolder), io.MultiWriter(tarOutput, pipeWriter)); err != nil </span><span class="cov0" title="0">{
                        errChan &lt;- err
                        return
                }</span>
                <span class="cov8" title="1">if err := pipeWriter.Close(); err != nil </span><span class="cov0" title="0">{
                        errChan &lt;- err
                        return
                }</span>
        }()

        // replace all the bramble store path prefixes with a known fixed value
        // also write this byte stream out as a tar to unpack later as the final output
        <span class="cov8" title="1">go func() </span><span class="cov8" title="1">{
                new := BramblePrefixOfRecord
                _, matches, err := textreplace.ReplaceStringsPrefix(
                        pipeReader, pipeWriter2, storeValues, oldStorePath, new)
                if err != nil </span><span class="cov0" title="0">{
                        errChan &lt;- err
                        return
                }</span>
                <span class="cov8" title="1">resultChan &lt;- matches
                if err := pipeWriter2.Close(); err != nil </span><span class="cov0" title="0">{
                        errChan &lt;- err
                        return
                }</span>
        }()

        // swap out references in the output to itself with null bytes so that
        // builds with a different randomly named build directory will still
        // match the hash of this one
        <span class="cov8" title="1">go func() </span><span class="cov8" title="1">{
                if _, err := textreplace.ReplaceBytes(
                        pipeReader2, hashOutput,
                        []byte(storeFolder), make([]byte, len(storeFolder)),
                ); err != nil </span><span class="cov0" title="0">{
                        errChan &lt;- err
                        return
                }</span>
                <span class="cov8" title="1">wg.Done()</span>
        }()

        <span class="cov8" title="1">select </span>{
        case err := &lt;-errChan:<span class="cov0" title="0">
                return nil, err</span>
        case result := &lt;-resultChan:<span class="cov8" title="1">
                for match := range result </span><span class="cov8" title="1">{
                        // remove prefix from dependency path
                        match = strings.TrimPrefix(strings.Replace(match, oldStorePath, "", 1), "/")
                        matches = append(matches, match)
                }</span>
        }
        <span class="cov8" title="1">wg.Wait()
        return</span>
}

func (b *Bramble) moduleNameFromFileName(filename string) (moduleName string, err error) <span class="cov0" title="0">{
        if !filepath.IsAbs(filename) </span><span class="cov0" title="0">{
                filename = filepath.Join(b.wd, filename)
        }</span>
        <span class="cov0" title="0">filename, err = filepath.Abs(filename)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">if !fileutil.FileExists(filename) </span><span class="cov0" title="0">{
                return "", errors.Errorf("bramble file %q doesn't exist", filename)
        }</span>
        <span class="cov0" title="0">if !strings.HasPrefix(filename, b.configLocation) </span><span class="cov0" title="0">{
                return "", errors.New("we don't support external modules yet")
        }</span>
        <span class="cov0" title="0">relativeWorkspacePath, err := filepath.Rel(b.configLocation, filename)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">moduleName = filepath.Join("github.com/maxmcd/bramble", relativeWorkspacePath)
        moduleName = strings.TrimSuffix(moduleName, "/default"+BrambleExtension)
        moduleName = strings.TrimSuffix(moduleName, BrambleExtension)
        return</span>
}

func (b *Bramble) createTmpFile() (f *os.File, err error) <span class="cov8" title="1">{
        return ioutil.TempFile(b.store.StorePath, BuildDirPattern)
}</span>

func (b *Bramble) writeDerivation(drv *Derivation) error <span class="cov8" title="1">{
        filename := drv.filename()
        fileLocation := b.store.JoinStorePath(filename)

        return ioutil.WriteFile(fileLocation, drv.JSON(), 0644)
}</span>

func (b *Bramble) fetchGitBuilder(ctx context.Context, drv *Derivation, outputPaths map[string]string) (err error) <span class="cov0" title="0">{
        region := trace.StartRegion(ctx, "fetchGitBuilder")
        defer region.End()

        certPool, err := gocertifi.CACerts()
        customClient := &amp;http.Client{
                Transport: &amp;http.Transport{
                        TLSClientConfig: &amp;tls.Config{RootCAs: certPool},
                },
        }

        // Override http(s) default protocol to use our custom client
        gitclient.InstallProtocol("https", githttp.NewClient(customClient))
        _, _ = git.PlainClone("", false, &amp;git.CloneOptions{})

        if _, ok := outputPaths["out"]; len(outputPaths) &gt; 1 || !ok </span><span class="cov0" title="0">{
                return errors.New("the fetchurl builtin can only have the defalt output \"out\"")
        }</span>
        <span class="cov0" title="0">url, ok := drv.Env["url"]
        if !ok </span><span class="cov0" title="0">{
                return errors.New("fetch_url requires the environment variable 'url' to be set")
        }</span>
        // derivation can provide a hash, but usually this is just in the lockfile
        <span class="cov0" title="0">hash := drv.Env["hash"]
        path, err := b.downloadFile(ctx, url, hash)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        // TODO: what if this package changes?
        <span class="cov0" title="0">if err = archiver.Unarchive(path, outputPaths["out"]); err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "error unpacking url archive")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (b *Bramble) fetchURLBuilder(ctx context.Context, drv *Derivation, outputPaths map[string]string) (err error) <span class="cov8" title="1">{
        region := trace.StartRegion(ctx, "fetchURLBuilder")
        defer region.End()

        if _, ok := outputPaths["out"]; len(outputPaths) &gt; 1 || !ok </span><span class="cov0" title="0">{
                return errors.New("the fetchurl builtin can only have the defalt output \"out\"")
        }</span>
        <span class="cov8" title="1">url, ok := drv.Env["url"]
        if !ok </span><span class="cov0" title="0">{
                return errors.New("fetch_url requires the environment variable 'url' to be set")
        }</span>
        // derivation can provide a hash, but usually this is just in the lockfile
        <span class="cov8" title="1">hash := drv.Env["hash"]
        path, err := b.downloadFile(ctx, url, hash)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        // TODO: what if this package changes?
        <span class="cov8" title="1">if err = archiver.Unarchive(path, outputPaths["out"]); err != nil </span><span class="cov0" title="0">{
                if !strings.Contains(err.Error(), "format unrecognized by filename") </span><span class="cov0" title="0">{
                        return errors.Wrap(err, "error unpacking url archive")
                }</span>
                <span class="cov0" title="0">return os.Rename(path, filepath.Join(outputPaths["out"], filepath.Base(url)))</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// Keep this, we'll need it at some point
func (b *Bramble) dockerRegularBuilder(ctx context.Context, drv *Derivation, buildDir string, outputPaths map[string]string) (err error) <span class="cov0" title="0">{
        region := trace.StartRegion(ctx, "dockerRegularBuilder")
        defer region.End()

        builderLocation := drv.Builder
        if _, err := os.Stat(builderLocation); err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "error checking if builder location exists")
        }</span>

        <span class="cov0" title="0">options := runDockerBuildOptions{
                buildDir:    buildDir,
                outputPaths: map[string]string{},
                env:         drv.env(),
                cmd:         append([]string{builderLocation}, drv.Args...),
                workingDir:  filepath.Join(buildDir, drv.BuildContextRelativePath),
        }

        for outputName, outputPath := range outputPaths </span><span class="cov0" title="0">{
                options.env = append(options.env, fmt.Sprintf("%s=%s", outputName, outputPath))
                options.outputPaths[outputName] = outputPath
        }</span>

        <span class="cov0" title="0">return b.runDockerBuild(ctx, drv.filename(), options)</span>
}

func (b *Bramble) regularBuilder(ctx context.Context, drv *Derivation, buildDir string,
        outputPaths map[string]string, shell bool) (err error) <span class="cov8" title="1">{
        builderLocation := drv.Builder
        if _, err := os.Stat(builderLocation); err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "builder location doesn't exist")
        }</span>
        <span class="cov8" title="1">env := drv.env()
        mounts := []string{
                b.store.StorePath + ":ro",
                buildDir,
                // "/dev/", //TODO: this can't be allowed
        }
        for outputName, outputPath := range outputPaths </span><span class="cov8" title="1">{
                env = append(env, fmt.Sprintf("%s=%s", outputName, outputPath))
                mounts = append(mounts, outputPath)
        }</span>
        <span class="cov8" title="1">if b.noRoot </span><span class="cov8" title="1">{
                cmd := exec.Cmd{
                        Path:   builderLocation,
                        Args:   append([]string{builderLocation}, drv.Args...),
                        Stdout: os.Stdout,
                        Stderr: os.Stderr,
                        Dir:    filepath.Join(buildDir, drv.BuildContextRelativePath),
                        Env:    env,
                }
                return cmd.Run()
        }</span>
        <span class="cov0" title="0">chrootDir, err := ioutil.TempDir("", "bramble-chroot-")
        // TODO: don't put it in tmp, put it in ~/bramble/var
        // chrootDir, err := b.store.TempBuildDir()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">u, err := user.Current()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">uid, _ := strconv.Atoi(u.Uid)
        gid, _ := strconv.Atoi(u.Gid)
        sbx := sandbox.Sandbox{
                Path:       builderLocation,
                Args:       drv.Args,
                Stdout:     os.Stdout,
                Stderr:     os.Stderr,
                UserID:     uid,
                GroupID:    gid,
                Env:        env,
                ChrootPath: chrootDir,
                Dir:        filepath.Join(buildDir, drv.BuildContextRelativePath),
                Mounts:     mounts,
        }
        if shell </span><span class="cov0" title="0">{
                sbx.Args = nil
                sbx.Stdin = os.Stdin
        }</span>
        <span class="cov0" title="0">return sbx.Run(ctx)</span>
}

// downloadFile downloads a file into the store. Must include an expected hash
// of the downloaded file as a hex string of a  sha256 hash
func (b *Bramble) downloadFile(ctx context.Context, url string, hash string) (path string, err error) <span class="cov8" title="1">{
        logger.Printfln("Downloading url %s", url)
        if hash != "" </span><span class="cov0" title="0">{
                byt, err := hex.DecodeString(hash)
                if err != nil </span><span class="cov0" title="0">{
                        err = errors.Wrap(err, fmt.Sprintf("error decoding hash %q; is it hexadecimal?", hash))
                        return "", err
                }</span>
                <span class="cov0" title="0">storePrefixHash := hasher.BytesToBase32Hash(byt)
                matches, err := filepath.Glob(b.store.JoinStorePath(storePrefixHash) + "*")
                if err != nil </span><span class="cov0" title="0">{
                        err = errors.Wrap(err, "error searching for existing hashed content")
                        return "", err
                }</span>
                <span class="cov0" title="0">if len(matches) != 0 </span><span class="cov0" title="0">{
                        return matches[0], nil
                }</span>
        }

        <span class="cov8" title="1">existingHash, exists := b.lockFile.URLHashes[url]
        if exists &amp;&amp; hash != "" &amp;&amp; hash != existingHash </span><span class="cov0" title="0">{
                return "", errors.Errorf("when downloading the file %q a hash %q was provided in"+
                        " code but the hash %q was in the lock file, exiting", url, hash, existingHash)
        }</span>

        // if we don't have a hash to validate, validate the one we already have
        <span class="cov8" title="1">if hash == "" &amp;&amp; exists </span><span class="cov0" title="0">{
                hash = existingHash
        }</span>

        <span class="cov8" title="1">req, err := http.NewRequestWithContext(ctx, http.MethodGet, url, nil)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov8" title="1">transport := &amp;http.Transport{
                DialContext: (&amp;net.Dialer{
                        Timeout:   30 * time.Second,
                        KeepAlive: 30 * time.Second,
                        DualStack: true,
                }).DialContext,
                ForceAttemptHTTP2:     true,
                MaxIdleConns:          100,
                IdleConnTimeout:       90 * time.Second,
                TLSHandshakeTimeout:   10 * time.Second,
                ExpectContinueTimeout: 1 * time.Second,
        }
        certPool, err := gocertifi.CACerts()
        transport.TLSClientConfig = &amp;tls.Config{RootCAs: certPool}

        client := http.Client{
                Transport: transport,
        }
        resp, err := client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                err = errors.Wrap(err, fmt.Sprintf("error making request to download %q", url))
                return
        }</span>
        <span class="cov8" title="1">defer resp.Body.Close()
        contentHash, path, err := b.store.WriteReader(resp.Body, filepath.Base(url), hash)
        if err == hasher.ErrHashMismatch </span><span class="cov0" title="0">{
                err = errors.Errorf(
                        "Got incorrect hash for url %s.\nwanted %q\ngot    %q",
                        url, hash, contentHash)
        }</span> else<span class="cov8" title="1"> if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">return path, b.addURLHashToLockfile(url, contentHash)</span>
}

func (b *Bramble) calculateDerivationInputSources(ctx context.Context, drv *Derivation) (err error) <span class="cov8" title="1">{
        region := trace.StartRegion(ctx, "calculateDerivationInputSources")
        defer region.End()

        if len(drv.sources.files) == 0 </span><span class="cov8" title="1">{
                return
        }</span>

        // TODO: should extend reptar to handle hasing the files before moving
        // them to a tempdir
        <span class="cov8" title="1">tmpDir, err := b.store.TempDir()
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">sources := drv.sources
        drv.sources.files = []string{}
        absDir, err := filepath.Abs(drv.sources.location)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        // get absolute paths for all sources
        <span class="cov8" title="1">for i, src := range sources.files </span><span class="cov8" title="1">{
                sources.files[i] = filepath.Join(b.configLocation, src)
        }</span>
        <span class="cov8" title="1">prefix := fileutil.CommonFilepathPrefix(append(sources.files, absDir))
        relBramblefileLocation, err := filepath.Rel(prefix, absDir)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">if err = fileutil.CopyFilesByPath(prefix, sources.files, tmpDir); err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        // sometimes the location the derivation runs from is not present
        // in the structure of the copied source files. ensure that we add it
        <span class="cov8" title="1">runLocation := filepath.Join(tmpDir, relBramblefileLocation)
        if err = os.MkdirAll(runLocation, 0755); err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">hshr := hasher.NewHasher()
        if err = reptar.Reptar(tmpDir, hshr); err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">storeLocation := b.store.JoinStorePath(hshr.String())
        if fileutil.PathExists(storeLocation) </span><span class="cov8" title="1">{
                if err = os.RemoveAll(tmpDir); err != nil </span><span class="cov0" title="0">{
                        return
                }</span>
        } else<span class="cov8" title="1"> {
                if err = os.Rename(tmpDir, storeLocation); err != nil </span><span class="cov0" title="0">{
                        return
                }</span>
        }
        <span class="cov8" title="1">drv.BuildContextSource = hshr.String()
        drv.BuildContextRelativePath = relBramblefileLocation
        drv.SourcePaths = append(drv.SourcePaths, hshr.String())
        sort.Strings(drv.SourcePaths)
        return</span>
}

func (b *Bramble) stringsReplacerForOutputs(outputs DerivationOutputs) (replacer *strings.Replacer, err error) <span class="cov0" title="0">{
        // Find all the replacements we need to make, template strings need to
        // become filesystem paths
        replacements := []string{}
        for _, do := range outputs </span><span class="cov0" title="0">{
                d := b.derivations.Load(do.Filename)
                if d == nil </span><span class="cov0" title="0">{
                        return nil, errors.Errorf(
                                "couldn't find a derivation with the filename %q in our cache. have we built it yet?", do.Filename)
                }</span>
                <span class="cov0" title="0">path := filepath.Join(
                        b.store.StorePath,
                        d.Output(do.OutputName).Path,
                )
                replacements = append(replacements, do.templateString(), path)</span>
        }
        // Replace the content using the json body and then convert it back into a
        // new derivation
        <span class="cov0" title="0">return strings.NewReplacer(replacements...), nil</span>
}

func (b *Bramble) copyDerivationWithOutputValuesReplaced(drv *Derivation) (copy *Derivation, err error) <span class="cov0" title="0">{
        // Find all derivation output template strings within the derivation
        outputs := drv.InputDerivations

        replacer, err := b.stringsReplacerForOutputs(outputs)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">replacedJSON := replacer.Replace(string(drv.JSON()))
        err = json.Unmarshal([]byte(replacedJSON), &amp;copy)
        return copy, err</span>
}

type BuildResult struct {
        Derivation *Derivation
        DidBuild   bool
}

func (b *Bramble) buildDerivations(ctx context.Context, derivations []*Derivation, skipDerivation *Derivation) (
        result []BuildResult, err error) <span class="cov8" title="1">{
        // TODO: instead of assembling this graph from dos, generate the dependency graph for each
        // derivation and then just merge the graphs with a fake root

        graphs := []*AcyclicGraph{}
        for _, drv := range derivations </span><span class="cov8" title="1">{
                graph, err := drv.BuildDependencyGraph()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">graphs = append(graphs, graph)</span>
        }
        <span class="cov8" title="1">graph := mergeGraphs(graphs...)
        if graph == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">var wg sync.WaitGroup
        errChan := make(chan error)
        semaphore := make(chan struct{}, 1)
        var errored bool
        if err = graph.Validate(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">ctx, cancel := context.WithCancel(ctx)
        go func() </span><span class="cov8" title="1">{
                graph.Walk(func(v dag.Vertex) (_ error) </span><span class="cov8" title="1">{
                        if errored </span><span class="cov0" title="0">{
                                return
                        }</span>
                        <span class="cov8" title="1">semaphore &lt;- struct{}{}
                        defer func() </span><span class="cov8" title="1">{ &lt;-semaphore }</span>()
                        // serial for now

                        // Skip the rake root
                        <span class="cov8" title="1">if v == FakeDAGRoot </span><span class="cov0" title="0">{
                                return
                        }</span>
                        <span class="cov8" title="1">do := v.(DerivationOutput)
                        drv := b.derivations.Load(do.Filename)
                        drv.lock.Lock()
                        defer drv.lock.Unlock()

                        if skipDerivation != nil &amp;&amp; skipDerivation == drv </span><span class="cov0" title="0">{
                                // Is this enough of an equality check?
                                return
                        }</span>
                        <span class="cov8" title="1">wg.Add(1)
                        didBuild, err := b.buildDerivationIfNew(ctx, drv)
                        if err != nil </span><span class="cov0" title="0">{
                                // Passing the error might block, so we need an explicit Done
                                // call here.
                                wg.Done()
                                errored = true
                                logger.Print(err)
                                errChan &lt;- err
                                return
                        }</span>

                        // Post build processing of dependencies template values:
                        <span class="cov8" title="1">{
                                // We construct the template value using the DerivationOutput which
                                // uses the initial derivation output value
                                oldTemplateName := fmt.Sprintf(UnbuiltDerivationOutputTemplate, do.Filename, do.OutputName)

                                newTemplateName := drv.String()

                                for _, edge := range graph.EdgesTo(v) </span><span class="cov8" title="1">{
                                        if edge.Source() == FakeDAGRoot </span><span class="cov0" title="0">{
                                                continue</span>
                                        }
                                        <span class="cov8" title="1">childDO := edge.Source().(DerivationOutput)
                                        drv := b.derivations.Load(childDO.Filename)
                                        if err := drv.replaceValueInDerivation(oldTemplateName, newTemplateName); err != nil </span><span class="cov0" title="0">{
                                                panic(err)</span>
                                        }
                                }
                        }

                        <span class="cov8" title="1">result = append(result, BuildResult{Derivation: drv, DidBuild: didBuild})
                        wg.Done()
                        return</span>
                })
                <span class="cov8" title="1">errChan &lt;- nil</span>
        }()
        <span class="cov8" title="1">err = &lt;-errChan
        cancel() // Call cancel on the context, no-op if nothing is running
        if err != nil </span><span class="cov0" title="0">{
                // If we receive an error cancel the context and wait for any jobs that
                // are running.
                wg.Wait()
        }</span>
        <span class="cov8" title="1">return result, err</span>
}

// Option can be used to set various options when initializing bramble
type Option func(*Bramble)

// OptionNoRoot ensures bramble don't use features that require root like setuid binaries
func OptionNoRoot(b *Bramble) <span class="cov8" title="1">{
        b.noRoot = true
}</span>

// NewBramble creates a new bramble instance. If the working directory passed is
// within a bramble project that projects configuration will be laoded
func NewBramble(wd string, opts ...Option) (b *Bramble, err error) <span class="cov8" title="1">{
        b = &amp;Bramble{}
        b.moduleCache = map[string]string{}
        b.filenameCache = NewBiStringMap()
        b.derivations = &amp;DerivationsMap{}
        b.wd = wd

        for _, opt := range opts </span><span class="cov8" title="1">{
                opt(b)
        }</span>

        // Make b.wd absolute
        <span class="cov8" title="1">if !filepath.IsAbs(b.wd) </span><span class="cov0" title="0">{
                wd, _ := os.Getwd()
                b.wd = filepath.Join(wd, b.wd)
        }</span>

        <span class="cov8" title="1">if b.store.IsEmpty() </span><span class="cov8" title="1">{
                if b.store, err = store.NewStore(); err != nil </span><span class="cov0" title="0">{
                        return
                }</span>
        }

        <span class="cov8" title="1">found, loc := findConfig(b.wd)
        if found </span><span class="cov8" title="1">{
                if err := b.loadConfig(loc); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        <span class="cov8" title="1">b.thread = &amp;starlark.Thread{
                Name: "main",
                Load: b.load,
        }

        return b, b.initPredeclared()</span>
}

func (b *Bramble) initPredeclared() (err error) <span class="cov8" title="1">{
        // creates the derivation function and checks we have a valid bramble path and store
        b.derivationFn = newDerivationFunction(b)

        assertGlobals, err := assert.LoadAssertModule()
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        // set the necessary error reporter so that the assert package can catch
        // errors
        <span class="cov8" title="1">assert.SetReporter(b.thread, runErrorReporter{})

        b.predeclared = starlark.StringDict{
                "derivation": b.derivationFn,
                "assert":     assertGlobals["assert"],
                "sys":        starlarkSys,
                "files":      starlark.NewBuiltin("files", b.filesBuiltin),
        }
        return</span>
}

func (b *Bramble) load(thread *starlark.Thread, module string) (globals starlark.StringDict, err error) <span class="cov8" title="1">{
        return b.resolveModule(module)
}</span>

func findAllDerivationsInProject(loc string) (derivations []*Derivation, err error) <span class="cov8" title="1">{
        b, err := NewBramble(loc)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if err := filepath.Walk(b.configLocation, func(path string, fi os.FileInfo, err error) error </span><span class="cov8" title="1">{
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                // TODO: ignore .git, ignore .gitignore?
                <span class="cov8" title="1">if strings.HasSuffix(path, ".bramble") </span><span class="cov8" title="1">{
                        module, err := b.filepathToModuleName(path)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">globals, err := b.resolveModule(module)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">for name, v := range globals </span><span class="cov8" title="1">{
                                if fn, ok := v.(*starlark.Function); ok </span><span class="cov8" title="1">{
                                        if fn.NumParams()+fn.NumKwonlyParams() &gt; 0 </span><span class="cov8" title="1">{
                                                continue</span>
                                        }
                                        <span class="cov8" title="1">fn.NumParams()
                                        value, err := starlark.Call(b.thread, fn, nil, nil)
                                        if err != nil </span><span class="cov0" title="0">{
                                                return errors.Wrapf(err, "calling %q in %s", name, path)
                                        }</span>
                                        <span class="cov8" title="1">derivations = append(derivations, valuesToDerivations(value)...)</span>
                                }
                        }
                }
                <span class="cov8" title="1">return nil</span>
        }); err != nil <span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return</span>
}

func (b *Bramble) execTestFileContents(script string) (v starlark.Value, err error) <span class="cov0" title="0">{
        globals, err := starlark.ExecFile(b.thread, filepath.Join(b.wd, "foo.bramble"), script, b.predeclared)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return starlark.Call(b.thread, globals["test"], nil, nil)</span>
}

func findBrambleFiles(path string) (brambleFiles []string, err error) <span class="cov0" title="0">{
        if fileutil.FileExists(path) </span><span class="cov0" title="0">{
                return []string{path}, nil
        }</span>
        <span class="cov0" title="0">if fileutil.FileExists(path + BrambleExtension) </span><span class="cov0" title="0">{
                return []string{path + BrambleExtension}, nil
        }</span>
        <span class="cov0" title="0">return brambleFiles, filepath.Walk(path, func(path string, fi os.FileInfo, err error) error </span><span class="cov0" title="0">{
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">if filepath.Ext(fi.Name()) != BrambleExtension </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov0" title="0">brambleFiles = append(brambleFiles, path)
                return nil</span>
        })
}

// runErrorReporter reports errors during a run. These errors are just passed up the thread
type runErrorReporter struct{}

func (e runErrorReporter) Error(err error) {<span class="cov0" title="0">}</span>
func (e runErrorReporter) FailNow() bool   <span class="cov0" title="0">{ return true }</span>

func (b *Bramble) compileStarlarkPath(path string) (prog *starlark.Program, err error) <span class="cov0" title="0">{
        compiledProgram, err := os.Open(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "error opening moduleCache storeLocation")
        }</span>
        <span class="cov0" title="0">return starlark.CompiledProgram(compiledProgram)</span>
}

func (b *Bramble) sourceStarlarkProgram(moduleName, filename string) (prog *starlark.Program, err error) <span class="cov8" title="1">{
        logger.Debugw("sourceStarlarkProgram", "moduleName", moduleName, "file", filename)
        b.filenameCache.Store(filename, moduleName)
        storeLocation, ok := b.moduleCache[moduleName]
        if ok </span><span class="cov0" title="0">{
                // we have a cached binary location in the cache map, so we just use that
                return b.compileStarlarkPath(b.store.JoinStorePath(storeLocation))
        }</span>

        // hash the file input
        <span class="cov8" title="1">f, err := os.Open(filename)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{ _ = f.Close() }</span>()
        <span class="cov8" title="1">hshr := hasher.NewHasher()
        if _, err = io.Copy(hshr, f); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">inputHash := hshr.String()

        inputHashStoreLocation := b.store.JoinBramblePath("var", "star-cache", inputHash)
        storeLocation, ok = fileutil.ValidSymlinkExists(inputHashStoreLocation)
        if ok </span><span class="cov0" title="0">{
                // if we have the hashed input on the filesystem cache and it points to a valid path
                // in the store, use that store path and add the cached location to the map
                relStoreLocation, err := filepath.Rel(b.store.StorePath, storeLocation)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">b.moduleCache[moduleName] = relStoreLocation
                return b.compileStarlarkPath(relStoreLocation)</span>
        }

        // if we're this far we don't have a cache of the program, process it directly
        <span class="cov8" title="1">if _, err = f.Seek(0, 0); err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">_, prog, err = starlark.SourceProgram(filename, f, b.predeclared.Has)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">var buf bytes.Buffer
        if err = prog.Write(&amp;buf); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">_, path, err := b.store.WriteReader(&amp;buf, filepath.Base(filename), "")
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">b.moduleCache[moduleName] = filepath.Base(path)
        _ = os.Remove(inputHashStoreLocation)
        return prog, os.Symlink(path, inputHashStoreLocation)</span>
}

func (b *Bramble) starlarkExecFile(moduleName, filename string) (globals starlark.StringDict, err error) <span class="cov8" title="1">{
        prog, err := b.sourceStarlarkProgram(moduleName, filename)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">g, err := prog.Init(b.thread, b.predeclared)
        for name := range g </span><span class="cov8" title="1">{
                // no importing or calling of underscored methods
                if strings.HasPrefix(name, "_") </span><span class="cov0" title="0">{
                        delete(g, name)
                }</span>
        }
        <span class="cov8" title="1">g.Freeze()
        return g, err</span>
}

func (b *Bramble) repl(_ []string) (err error) <span class="cov0" title="0">{
        repl.REPL(b.thread, b.predeclared)
        return nil
}</span>

func (b *Bramble) parseAndCallBuildArg(cmd string, args []string) (derivations []*Derivation, err error) <span class="cov8" title="1">{
        if len(args) == 0 </span><span class="cov0" title="0">{
                logger.Printfln(`"bramble %s" requires 1 argument`, cmd)
                err = flag.ErrHelp
                return
        }</span>

        // parse something like ./tests:foo into the correct module and function
        // name
        <span class="cov8" title="1">module, fn, err := b.parseModuleFuncArgument(args)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">logger.Debug("resolving module", module)
        // parse the module and all of its imports, return available functions
        globals, err := b.resolveModule(module)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">toCall, ok := globals[fn]
        if !ok </span><span class="cov0" title="0">{
                err = errors.Errorf("function %q not found in module %q", fn, module)
                return
        }</span>

        <span class="cov8" title="1">logger.Debug("Calling function ", fn)
        values, err := starlark.Call(&amp;starlark.Thread{}, toCall, nil, nil)
        if err != nil </span><span class="cov0" title="0">{
                err = errors.Wrap(err, "error running")
                return
        }</span>

        // The function must return a single derivation or a list of derivations, or
        // a tuple of derivations. We turn them into an array.
        <span class="cov8" title="1">derivations = valuesToDerivations(values)
        return</span>
}

func (b *Bramble) Shell(ctx context.Context, args []string) (result []BuildResult, err error) <span class="cov0" title="0">{
        if !b.withinProject() </span><span class="cov0" title="0">{
                return nil, ErrNotInProject
        }</span>
        <span class="cov0" title="0">derivations, err := b.parseAndCallBuildArg("build", args)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if len(derivations) &gt; 1 </span><span class="cov0" title="0">{
                return nil, errors.New(`cannot run "bramble shell" with a function that returns multiple derivations`)
        }</span>
        <span class="cov0" title="0">shellDerivation := derivations[0]

        if result, err = b.buildDerivations(ctx,
                derivations, shellDerivation); err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">if err := b.writeConfigMetadata(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">filename := shellDerivation.filename()
        logger.Print("Launching shell for derivation", filename)
        logger.Debugw(shellDerivation.PrettyJSON())
        if err = b.buildDerivation(ctx, shellDerivation, true); err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "error spawning "+filename)
        }</span>
        <span class="cov0" title="0">return result, nil</span>
}

func (b *Bramble) withinProject() bool <span class="cov8" title="1">{
        return b.configLocation != ""
}</span>

func (b *Bramble) Build(ctx context.Context, args []string) (derivations []*Derivation, buildResult []BuildResult, err error) <span class="cov8" title="1">{
        if !b.withinProject() </span><span class="cov0" title="0">{
                return nil, nil, ErrNotInProject
        }</span>
        <span class="cov8" title="1">if derivations, err = b.parseAndCallBuildArg("build", args); err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>
        <span class="cov8" title="1">if buildResult, err = b.buildDerivations(ctx, derivations, nil); err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">return derivations, buildResult, b.writeConfigMetadata()</span>
}

func valuesToDerivations(values starlark.Value) (derivations []*Derivation) <span class="cov8" title="1">{
        switch v := values.(type) </span>{
        case *Derivation:<span class="cov8" title="1">
                return []*Derivation{v}</span>
        case *starlark.List:<span class="cov0" title="0">
                for _, v := range starutil.ListToValueList(v) </span><span class="cov0" title="0">{
                        derivations = append(derivations, valuesToDerivations(v)...)
                }</span>
        case starlark.Tuple:<span class="cov0" title="0">
                for _, v := range v </span><span class="cov0" title="0">{
                        derivations = append(derivations, valuesToDerivations(v)...)
                }</span>
        }
        <span class="cov0" title="0">return</span>
}

func (b *Bramble) GC(_ []string) (err error) <span class="cov8" title="1">{
        derivations, err := b.collectDerivationsToPreserve()
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">pathsToKeep := map[string]struct{}{}

        graphs := []*AcyclicGraph{}
        for _, drv := range derivations </span><span class="cov8" title="1">{
                graph, err := drv.BuildDependencyGraph()
                if err != nil </span><span class="cov0" title="0">{
                        // if we can't fetch the full graph then it likely hasn't been built
                        // and we want to skip it. TODO: we might be skipping important things here?
                        continue</span>
                }
                <span class="cov8" title="1">graphs = append(graphs, graph)</span>
        }
        <span class="cov8" title="1">graph := mergeGraphs(graphs...)
        graph.Walk(func(v dag.Vertex) error </span><span class="cov8" title="1">{
                if v == FakeDAGRoot </span><span class="cov8" title="1">{
                        return nil
                }</span>
                <span class="cov8" title="1">do := v.(DerivationOutput)
                drv, exists, err := b.loadDerivation(do.Filename)
                if !exists </span><span class="cov8" title="1">{
                        return nil
                }</span>
                <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">for _, f := range append(drv.inputFiles(), drv.runtimeFiles(do.OutputName)...) </span><span class="cov8" title="1">{
                        pathsToKeep[f] = struct{}{}
                }</span>

                <span class="cov8" title="1">oldTemplateName := fmt.Sprintf(UnbuiltDerivationOutputTemplate, do.Filename, do.OutputName)
                newTemplateName := drv.String()
                for _, edge := range graph.EdgesTo(v) </span><span class="cov8" title="1">{
                        if edge.Source() == FakeDAGRoot </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov8" title="1">childDO := edge.Source().(DerivationOutput)
                        fmt.Println(childDO.Filename)
                        drv := b.deriv</span><span class="cov8" title="1">ations.Load(childDO.Filename)
                        if drv ==</span> nil {
                                continue
                        <span class="cov0" title="0">}
</span>                        if err := d</span>rv.replaceValueInDerivation(oldTemplateName, newTemplateName); err != nil {
                                panic(err)
                        }
                <span class="cov8" title="1">}
</span>                return nil
        })

        <span class="cov8" title="1">// delete everything in the store that's not in the map
        files, err := </span><span class="cov0" title="0">os.ReadDir(b.store.StorePath)
        if err != nil {
                </span>return
        <span class="cov8" title="1">}
</span>        for _, file := range files {
</span>                if _, ok </span>:= pathsToKeep[file.Name()]; ok {
                        continue
                <span class="cov8" title="1">}
                logger.Print("deleting", file.Name())
</span>                if err = os.RemoveAll(b.store.JoinStorePath(file.Name())); err != nil {
                        </span>return err
                }
        <span class="cov8" title="1">}
</span>        return nil
}

func (b *Bramble) collectDerivationsToPreserve() (derivations []*Derivation, err error) {
        registryFolder := b.store.JoinBramblePath("var", "config-registry")
        files, err := </span><span class="cov0" title="0">ioutil.ReadDir(registryFolder)
        if err != nil {
                </span>return
        }

</span>        for _, f := range files {
                registryLoc := filepath.Join(registryFolder, f.Name())
                pathBytes, err</span><span class="cov0" title="0"> := ioutil.ReadFile(registryLoc)
                if err != nil {
                        </span>return nil, err
                <span class="cov8" title="1">}
                path := string(pathBytes)
</span>                if !fileutil.FileExists(filepath.Join(path, "bramble.toml")) {
                        logger.Printfln("deleting cache for %q, it no longer exists", path)
                        _ = os.R</span>emove(registryLoc)
                        continue
                }

                drvs, err := f</span><span class="cov0" title="0">indAllDerivationsInProject(path)
                if err != nil {
                        // TODO: this is heavy handed, would mean any syntax error in any
                        // project prevents a global gc, think about how to deal with this
                        </span>return nil, errors.Wrapf(err, "error computing derivations in %q", registryLoc)
                <span class="cov8" title="1">}
</span>                derivations = append(derivations, drvs...)
        <span class="cov8" title="1">}
</span>        return
}

func (b *Bramble) loadDerivation(filename string) (drv *Derivation, exists bool, err error) {
        defer logger.Debug("loadDerivation ", filename, " ", exists)
        drv = b.derivations.Load(filename)
        // TODO: confirm derivations can be tr</span><span class="cov8" title="1">eated as immutable if they have outputs
        if drv != nil &amp;&amp; !drv.MissingOutput() {
                </span>return drv, true, nil
        <span class="cov8" title="1">}
        loc := b.store.JoinStorePath(</span><span class="cov8" title="1">filename)
        if !fileutil.FileExists(loc) {
                // If we have </span><span class="cov8" title="1">the derivation in memory just return it
                if drv != nil {
                        </span>return drv, false, nil
                <span class="cov8" title="1">}
</span>                return nil, false, errors.WithStack(os.ErrNotExist)
        <span class="cov8" title="1">}
        f, err := os.O</span><span class="cov0" title="0">pen(loc)
        if err != nil {
                </span>return nil, true, errors.WithStack(err)
        <span class="cov8" title="1">}
</span></span>        <span class="cov8" title="1">defer func() { _ = f.Close() }()
        drv = &amp;Derivation{}
        drv.bramble = b
</span>        if err = json.NewDecoder(f).Decode(&amp;drv); err != nil {
                </span>return
        <span class="cov8" title="1">}
        b.derivations.Store(f</span>ilename, drv)
        return drv, true, nil
}

func (b *Bramble) derivationBuild(args []string) error {
        </span>return nil
}

func (b *Bramble) filepathToModuleName(path str</span><span class="cov0" title="0">ing) (module string, err error) {
        if !strings.HasSuffix(path, BrambleExtension) {
                </span>return "", errors.Errorf("path %q is not a bramblefile", path)
        <span class="cov8" title="1">}
</span>        if !fileutil.FileExists(path) {
                </span>return "", errors.Wrap(os.ErrNotExist, path)
        <span class="cov8" title="1">}
        rel, err := fi</span><span class="cov0" title="0">lepath.Rel(b.configLocation, path)
        if err != nil {
                </span>return "", errors.Wrapf(err, "%q is not relative to the project directory %q", path, b.configLocation)
        <span class="cov8" title="1">}
</span>        if strings.HasSuffix(path, "default"+BrambleExtension) {
                </span>rel =<span class="cov8" title="1"> strings.TrimSuffix(rel, "default"+BrambleExtension)
        } else {
                </span>rel = strings.TrimSuffix(rel, BrambleExtension)
        <span class="cov8" title="1">}
        rel = strings.TrimSuffix(rel, "/")
</span>        return b.config.Module.Name + "/" + rel, nil
}

func (b *Bramble) resolveModule(module string) (globa</span><span class="cov0" title="0">ls starlark.StringDict, err error) {
        if !strings.HasPrefix(module, b.config.Module.Name) {
                // TODO: support other modules
                debug.PrintStack()
                err = errors.Errorf("can't find module %s", module)
                </span>return
        }

</span>        if _, ok := b.moduleCache[module]; ok {
                filename, e</span><span class="cov0" title="0">xists := b.filenameCache.LoadInverse(module)
                if !exists {
                        </span>return nil, errors.Errorf("module %q returns no matching filename", module)
                <span class="cov0" title="0">}
</span>                return b.starlarkExecFile(module, filename)
        }

        path := module[len(b.config.Module.Name):]
        path = filepath.Join(b.configLocation, path)

        directoryWithNameExists := fileutil.PathExists(path)

        var directoryHasDefaultDotB</span><span class="cov8" title="1">ramble bool
        if directoryWithNameExists {
                </span>directoryHasDefaultDotBramble = fileutil.FileExists(path + "/default.bramble")
        }

        fileWithNameExists := fileutil.FileExists(path + BrambleExtension)

</span>        switch {
        case directoryWithNameExist</span>s &amp;&amp; directoryHasDefaultDotBramble:
                path += "/default.bramb<span class="cov8" title="1">le"
        case fileWithNameExists:
</span>                path +=<span class="cov0" title="0"> BrambleExtension
        default:
                err = </span>errors.WithStack(errModuleDoesNotExist(module))
                return
        }

</span>        return b.starlarkExecFile(module, path)
}

func (b *Bramble) moduleFromPath(path string) (thisModule string, err error) {
        thisModule = (b.config.Module.Name + "/" + b.relativePathFromConfig())

        // See if this path is actually the name of a module, for now we just
        // support one module.
        // TODO: search through all modules in scope for </span><span class="cov0" title="0">this config
        if strings.HasPrefix(path, b.config.Module.Name) {
                </span>return path, nil
        }

        <span class="cov8" title="1">// if the relative path is nothing, we'</span><span class="cov0" title="0">ve already added the slash above
        if !strings.HasSuffix(thisModule, "/") {
                </span>thisModule += "/"
        }

        <span class="cov8" title="1">// support things like bar/main.bramble:foo
</span>        if strings.HasSuffix(path, BrambleExtension) &amp;&amp; fileutil.FileExists(filepath.Join(b.wd, path)) {
                </span>return thisModule + path[:len(path)-len(BrambleExtension)], nil
        }

        fullName := path + BrambleExtension
</span>        if !fileutil.FileExists(filepath.Join(b.wd, fullName)) {
</span>                if !fileutil.FileExists(filepath.Join(b.wd, path+"/default.bramble")) {
                        </span>return "", errors.Errorf("%q: no such file or directory", path)
                }
        }
        <span class="cov8" title="1">// we found it, return
        thisModule += filepath.Join(path)
</span>        return strings.TrimSuffix(thisModule, "/"), nil
}

func (b *Bramble) relativePathFromConfig() string {
        relativePath, _ := file</span><span class="cov8" title="1">path.Rel(b.configLocation, b.wd)
        if relativePath == "." {
                // don't add a dot to the path
                </span>return ""
        <span class="cov0" title="0">}
</span>        return relativePath
}

func (b *Bramble) p</span><span class="cov0" title="0">arseModuleFuncArgument(args []string) (module, function string, err error) {
        if len(args) == 0 {
                logger.Print(`"bramble build" requires 1 argument`)
                </span>return "", "", flag.ErrHelp
        }

        firstArgument := args[0]
        lastIndex := stri</span><span class="cov0" title="0">ngs.LastIndex(firstArgument, ":")
        if lastIndex &lt; 0 {
                logger.Print("module and function argument is not properly formatted")
                </span>return "", "", flag.ErrHelp
        <span class="cov8" title="1">}
        path, function := firstArgument[:lastIndex], firstArgument[lastIndex+1:]
        module, err = b.moduleFromPath(path)
        fmt.Pr</span>intln(module, err)
        return
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package bramble

import (
        "encoding/json"
        "strings"

        "github.com/maxmcd/bramble/pkg/fileutil"
        "github.com/maxmcd/dag"
        "github.com/pkg/errors"
)

func (drv *Derivation) BuildDependencyGraph() (graph *AcyclicGraph, err error) <span class="cov8" title="1">{
        graph = NewAcyclicGraph()
        var processInputDerivations func(drv *Derivation, do DerivationOutput) error
        processInputDerivations = func(drv *Derivation, do DerivationOutput) error </span><span class="cov8" title="1">{
                graph.Add(do)
                for _, id := range drv.InputDerivations </span><span class="cov8" title="1">{
                        inputDrv, _, err := drv.bramble.loadDerivation(id.Filename)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">graph.Add(id)
                        graph.Connect(dag.BasicEdge(do, id))
                        if err := processInputDerivations(inputDrv, id); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
                <span class="cov8" title="1">return nil</span>
        }
        <span class="cov8" title="1">dos := drv.DerivationOutputs()

        // If there are multiple build outputs we'll need to create a fake root and
        // connect all of the build outputs to our fake root.
        if len(dos) &gt; 1 </span><span class="cov8" title="1">{
                graph.Add(FakeDAGRoot)
                for _, do := range dos </span><span class="cov8" title="1">{
                        graph.Connect(dag.BasicEdge(FakeDAGRoot, do))
                }</span>
        }
        <span class="cov8" title="1">for _, do := range dos </span><span class="cov8" title="1">{
                if err = processInputDerivations(drv, do); err != nil </span><span class="cov0" title="0">{
                        return
                }</span>
        }
        <span class="cov8" title="1">return</span>
}

// RuntimeDependencyGraph graphs the full dependency graph needed at runtime for
// all outputs. Includes all immediate dependencies and their dependencies
func (drv *Derivation) RuntimeDependencyGraph() (graph *AcyclicGraph, err error) <span class="cov8" title="1">{
        graph = NewAcyclicGraph()
        noOutput := errors.New("outputs missing on derivation when searching for runtime dependencies")
        if drv.MissingOutput() </span><span class="cov0" title="0">{
                return nil, noOutput
        }</span>
        <span class="cov8" title="1">var processDerivationOutputs func(do DerivationOutput) error
        processDerivationOutputs = func(do DerivationOutput) error </span><span class="cov8" title="1">{
                drv, _, err := drv.bramble.loadDerivation(do.Filename)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">if drv.MissingOutput() </span><span class="cov0" title="0">{
                        return noOutput
                }</span>
                <span class="cov8" title="1">dependencies, err := drv.runtimeDependencies()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">graph.Add(do)
                for _, dependency := range dependencies[do.OutputName] </span><span class="cov8" title="1">{
                        graph.Add(dependency)
                        graph.Connect(dag.BasicEdge(do, dependency))
                        if err := processDerivationOutputs(dependency); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
                <span class="cov8" title="1">return nil</span>
        }
        <span class="cov8" title="1">for _, do := range drv.DerivationOutputs() </span><span class="cov8" title="1">{
                if err := processDerivationOutputs(do); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }
        <span class="cov8" title="1">return graph, nil</span>
}

func (drv *Derivation) runtimeDependencies() (dependencies map[string][]DerivationOutput, err error) <span class="cov8" title="1">{
        inputDerivations, err := drv.inputDerivations()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">dependencies = map[string][]DerivationOutput{}
        outputInputMap := map[string]DerivationOutput{}
        // Map output derivations with the input that created the output
        for do, drv := range inputDerivations </span><span class="cov8" title="1">{
                for i, output := range drv.Outputs </span><span class="cov8" title="1">{
                        if drv.OutputNames[i] == do.OutputName </span><span class="cov8" title="1">{
                                outputInputMap[output.Path] = do
                        }</span>
                }
        }
        <span class="cov8" title="1">for i, out := range drv.Outputs </span><span class="cov8" title="1">{
                dos := []DerivationOutput{}
                for _, dependency := range out.Dependencies </span><span class="cov8" title="1">{
                        dos = append(dos, outputInputMap[dependency])
                }</span>
                <span class="cov8" title="1">dependencies[drv.OutputNames[i]] = dos</span>
        }
        <span class="cov8" title="1">return dependencies, err</span>
}

func (drv *Derivation) inputDerivations() (inputDerivations map[DerivationOutput]*Derivation, err error) <span class="cov8" title="1">{
        inputDerivations = make(map[DerivationOutput]*Derivation)
        for _, do := range drv.InputDerivations </span><span class="cov8" title="1">{
                inputDrv, _, err := drv.bramble.loadDerivation(do.Filename)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">inputDerivations[do] = inputDrv</span>
        }
        <span class="cov8" title="1">return</span>
}

func (drv *Derivation) inputFiles() []string <span class="cov8" title="1">{
        return append([]string{drv.filename()}, drv.SourcePaths...)
}</span>

func (drv *Derivation) runtimeFiles(outputName string) []string <span class="cov8" title="1">{
        return []string{drv.filename(), drv.Output(outputName).Path}
}</span>

func (drv *Derivation) populateOutputsFromStore() (exists bool, err error) <span class="cov8" title="1">{
        filename := drv.filename()
        var outputs []Output
        outputs, exists, err = drv.bramble.checkForExistingDerivation(filename)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">if exists </span><span class="cov8" title="1">{
                drv.Outputs = outputs
                drv.bramble.derivations.Store(filename, drv)
        }</span>
        <span class="cov8" title="1">return</span>
}

func (drv *Derivation) replaceValueInDerivation(old, new string) (err error) <span class="cov8" title="1">{
        var dummyDrv Derivation
        if err := json.Unmarshal([]byte(strings.ReplaceAll(string(drv.JSON()), old, new)), &amp;dummyDrv); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">drv.Args = dummyDrv.Args
        drv.Env = dummyDrv.Env
        drv.Builder = dummyDrv.Builder
        return nil</span>
}

func (drv *Derivation) copyWithOutputValuesReplaced() (copy *Derivation, err error) <span class="cov8" title="1">{
        s := string(drv.JSON())
        for _, match := range BuiltTemplateStringRegexp.FindAllStringSubmatch(s, -1) </span><span class="cov8" title="1">{
                storePath := drv.bramble.store.JoinStorePath(match[1])
                if fileutil.PathExists(storePath) </span><span class="cov8" title="1">{
                        s = strings.ReplaceAll(s, match[0], storePath)
                }</span>
        }
        <span class="cov8" title="1">return copy, json.Unmarshal([]byte(s), &amp;copy)</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package bramble

import (
        "context"
        "flag"
        "fmt"
        "io/ioutil"
        "log"
        "os"
        "strings"
        "text/tabwriter"

        "github.com/maxmcd/bramble/pkg/logger"
        "github.com/maxmcd/bramble/pkg/sandbox"
        "github.com/maxmcd/bramble/pkg/starutil"
        "github.com/peterbourgon/ff/v3/ffcli"
)

var (
        BrambleFunctionBuildHiddenCommand = "__bramble-function-build"
)

func (b *Bramble) createAndParseCLI(args []string) (*ffcli.Command, error) <span class="cov0" title="0">{
        var (
                root            *ffcli.Command
                repl            *ffcli.Command
                shell           *ffcli.Command
                build           *ffcli.Command
                store           *ffcli.Command
                storeGC         *ffcli.Command
                storeAudit      *ffcli.Command
                derivation      *ffcli.Command
                derivationBuild *ffcli.Command
                rootFlagSet     = flag.NewFlagSet("bramble", flag.ExitOnError)
                version         = rootFlagSet.Bool("version", false, "version")
        )

        build = &amp;ffcli.Command{
                Name:       "build",
                ShortUsage: "bramble build [options] [module]:&lt;function&gt; [args...]",
                ShortHelp:  "Build a function",
                LongHelp:   "Build a function",
                Exec:       func(ctx context.Context, args []string) error </span><span class="cov0" title="0">{ _, _, err := b.Build(ctx, args); return err }</span>,
        }

        <span class="cov0" title="0">shell = &amp;ffcli.Command{
                Name:       "shell",
                ShortUsage: "bramble shell [options] [module]:&lt;function&gt; [args...]",
                ShortHelp:  "Open a shell from a derivation",
                LongHelp:   "Open a shell from a derivation",
                Exec:       func(ctx context.Context, args []string) error </span><span class="cov0" title="0">{ _, err := b.Shell(ctx, args); return err }</span>,
        }

        <span class="cov0" title="0">repl = &amp;ffcli.Command{
                Name:       "repl",
                ShortUsage: "bramble repl",
                ShortHelp:  "Run an interactive shell",
                Exec:       func(ctx context.Context, args []string) error </span><span class="cov0" title="0">{ return b.repl(args) }</span>,
        }

        <span class="cov0" title="0">storeGC = &amp;ffcli.Command{
                Name:       "gc",
                ShortUsage: "bramble store gc",
                ShortHelp:  "Run the bramble garbage collector against the store",
                LongHelp: `    Collect garbage

        'Bramble gc' will clean up unused files and dependencies from the bramble
        store. This includes cache files, artifacts, and derivations that were used as
        build inputs that are no longer needed to run resulting programs.
        `,
                Exec: func(ctx context.Context, args []string) error </span><span class="cov0" title="0">{
                        return b.GC(args)
                }</span>,
        }

        <span class="cov0" title="0">storeAudit = &amp;ffcli.Command{
                Name:       "audit",
                ShortUsage: "bramble store audit",
                ShortHelp:  "",
                LongHelp:   "",
                Exec: func(ctx context.Context, args []string) error </span><span class="cov0" title="0">{
                        return b.GC(args)
                }</span>,
        }

        <span class="cov0" title="0">store = &amp;ffcli.Command{
                Name:        "store",
                ShortUsage:  "bramble store &lt;subcommand&gt;",
                ShortHelp:   "Interact with the store",
                Exec:        func(ctx context.Context, args []string) error </span><span class="cov0" title="0">{ return flag.ErrHelp }</span>,
                Subcommands: []*ffcli.Command{storeGC, storeAudit},
        }

        <span class="cov0" title="0">derivationBuild = &amp;ffcli.Command{
                Name:       "build",
                ShortUsage: "bramble derivation build ~/bramble/store/3orpqhjdgtvfbqbhpecro3qe6heb3jvq-simple.drv",
                Exec:       func(ctx context.Context, args []string) error </span><span class="cov0" title="0">{ return b.derivationBuild(args) }</span>,
        }
        <span class="cov0" title="0">derivation = &amp;ffcli.Command{
                Name:        "derivation",
                ShortUsage:  "bramble derivation &lt;subcomand&gt;",
                ShortHelp:   "Work with derivations directly",
                Subcommands: []*ffcli.Command{derivationBuild},
                Exec:        func(ctx context.Context, args []string) error </span><span class="cov0" title="0">{ return flag.ErrHelp }</span>,
        }

        <span class="cov0" title="0">root = &amp;ffcli.Command{
                ShortUsage:  "bramble [flags] &lt;command&gt; [&lt;args&gt;]",
                Subcommands: []*ffcli.Command{build, repl, store, shell, derivation},
                FlagSet:     rootFlagSet,
                UsageFunc:   DefaultUsageFunc,
                Exec: func(ctx context.Context, args []string) error </span><span class="cov0" title="0">{
                        if *version </span><span class="cov0" title="0">{
                                logger.Print("0.0.1")
                                return nil
                        }</span>
                        <span class="cov0" title="0">return flag.ErrHelp</span>
                },
        }

        // Recursively patch all command descriptions and usage functions
        <span class="cov0" title="0">var fixup func(*ffcli.Command)
        fixup = func(cmd *ffcli.Command) </span><span class="cov0" title="0">{
                for _, c := range cmd.Subcommands </span><span class="cov0" title="0">{
                        c.UsageFunc = DefaultUsageFunc
                        // replace tabs in help with 4 width spaces
                        c.LongHelp = strings.ReplaceAll(c.LongHelp, "\t", "    ")
                        fixup(c)
                }</span>
        }
        <span class="cov0" title="0">fixup(root)

        if err := root.Parse(args); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return root, nil</span>
}

// RunCLI runs the cli with os.Args
func RunCLI() <span class="cov0" title="0">{
        sandbox.Entrypoint()

        log.SetOutput(ioutil.Discard)
        b := &amp;Bramble{}
        handleErr := func(err error) </span><span class="cov0" title="0">{
                if err == errQuiet </span><span class="cov0" title="0">{
                        os.Exit(1)
                }</span>
                <span class="cov0" title="0">if err == flag.ErrHelp </span><span class="cov0" title="0">{
                        os.Exit(127)
                }</span>
                <span class="cov0" title="0">logger.Print(starutil.AnnotateError(err))
                os.Exit(1)</span>
        }

        <span class="cov0" title="0">command, err := b.createAndParseCLI(os.Args[1:])
        if err != nil </span><span class="cov0" title="0">{
                handleErr(err)
        }</span>
        // TODO, use context to handle interrupt
        <span class="cov0" title="0">if err := command.Run(context.Background()); err != nil </span><span class="cov0" title="0">{
                handleErr(err)
        }</span>
}

func DefaultUsageFunc(c *ffcli.Command) string <span class="cov0" title="0">{
        var b strings.Builder

        fmt.Fprintf(&amp;b, "Usage: ")
        if c.ShortUsage != "" </span><span class="cov0" title="0">{
                fmt.Fprintf(&amp;b, "%s\n", c.ShortUsage)
        }</span> else<span class="cov0" title="0"> {
                fmt.Fprintf(&amp;b, "%s\n", c.Name)
        }</span>
        <span class="cov0" title="0">fmt.Fprintf(&amp;b, "\n")

        if c.LongHelp != "" </span><span class="cov0" title="0">{
                fmt.Fprintf(&amp;b, "%s\n\n", c.LongHelp)
        }</span>

        <span class="cov0" title="0">if len(c.Subcommands) &gt; 0 </span><span class="cov0" title="0">{
                fmt.Fprintf(&amp;b, "Commands:\n")
                tw := tabwriter.NewWriter(&amp;b, 0, 4, 4, ' ', 0)
                for _, subcommand := range c.Subcommands </span><span class="cov0" title="0">{
                        fmt.Fprintf(tw, "\t%s\t%s\n", subcommand.Name, subcommand.ShortHelp)
                }</span>
                <span class="cov0" title="0">tw.Flush()
                fmt.Fprintf(&amp;b, "\n")</span>
        }

        <span class="cov0" title="0">if countFlags(c.FlagSet) &gt; 0 </span><span class="cov0" title="0">{
                fmt.Fprintf(&amp;b, "Flags:\n")
                tw := tabwriter.NewWriter(&amp;b, 0, 2, 2, ' ', 0)
                c.FlagSet.VisitAll(func(f *flag.Flag) </span><span class="cov0" title="0">{
                        fmt.Fprintf(tw, "  --%s\t%s\n", f.Name, f.Usage)
                }</span>)
                <span class="cov0" title="0">tw.Flush()
                fmt.Fprintf(&amp;b, "\n")</span>
        }

        <span class="cov0" title="0">return strings.TrimSpace(b.String())</span>
}
func countFlags(fs *flag.FlagSet) (n int) <span class="cov0" title="0">{
        fs.VisitAll(func(*flag.Flag) </span><span class="cov0" title="0">{ n++ }</span>)
        <span class="cov0" title="0">return n</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package bramble

import (
        "fmt"
        "os"
        "path/filepath"

        "github.com/BurntSushi/toml"
        "github.com/maxmcd/bramble/pkg/fileutil"
        "github.com/pkg/errors"
)

type Config struct {
        Module ConfigModule `toml:"module"`
}
type ConfigModule struct {
        Name string `toml:"name"`
}

func findConfig(wd string) (found bool, location string) <span class="cov8" title="1">{
        if o, _ := filepath.Abs(wd); o != "" </span><span class="cov8" title="1">{
                wd = o
        }</span>
        <span class="cov8" title="1">for </span><span class="cov8" title="1">{
                if fileutil.FileExists(filepath.Join(wd, "bramble.toml")) </span><span class="cov8" title="1">{
                        return true, wd
                }</span>
                <span class="cov0" title="0">fmt.Println(wd, filepath.Join(wd, ".."))
                if wd == filepath.Join(wd, "..") </span><span class="cov0" title="0">{
                        return false, ""
                }</span>
                <span class="cov0" title="0">wd = filepath.Join(wd, "..")</span>
        }
}

func (b *Bramble) loadConfig(location string) (err error) <span class="cov8" title="1">{
        b.configLocation = location
        bDotToml := filepath.Join(location, "bramble.toml")
        f, err := os.Open(bDotToml)
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrapf(err, "error loading %q", bDotToml)
        }</span>
        <span class="cov8" title="1">defer f.Close()
        if _, err = toml.DecodeReader(f, &amp;b.config); err != nil </span><span class="cov0" title="0">{
                return errors.Wrapf(err, "error decoding %q", bDotToml)
        }</span>
        <span class="cov8" title="1">lockFile := filepath.Join(location, "bramble.lock")
        if !fileutil.FileExists(lockFile) </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">f, err = os.Open(lockFile)
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrapf(err, "error opening lockfile %q", lockFile)
        }</span>
        <span class="cov8" title="1">defer f.Close()
        _, err = toml.DecodeReader(f, &amp;b.lockFile)
        return errors.Wrapf(err, "error decoding lockfile %q", lockFile)</span>
}

type LockFile struct {
        URLHashes map[string]string
}

func (b *Bramble) writeConfigMetadata() (err error) <span class="cov8" title="1">{
        return b.store.WriteConfigLink(b.configLocation)
}</span>

func (b *Bramble) addURLHashToLockfile(url, hash string) (err error) <span class="cov8" title="1">{
        b.lockFileLock.Lock()
        defer b.lockFileLock.Unlock()

        f, err := os.OpenFile(filepath.Join(b.configLocation, "bramble.lock"),
                os.O_RDWR|os.O_APPEND|os.O_CREATE, 0644)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{ _ = f.Close() }</span>()

        <span class="cov8" title="1">lf := LockFile{
                URLHashes: map[string]string{},
        }
        if _, err = toml.DecodeReader(f, &amp;lf); err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">_ = f.Truncate(0)
        _, _ = f.Seek(0, 0)
        if v, ok := lf.URLHashes[url]; ok &amp;&amp; v != hash </span><span class="cov0" title="0">{
                return errors.Errorf("found existing hash for %q with value %q not %q, not sure how to proceed", url, v, hash)
        }</span>
        <span class="cov8" title="1">lf.URLHashes[url] = hash

        return toml.NewEncoder(f).Encode(&amp;lf)</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package bramble

import (
        "fmt"
        "strings"
        "sync"

        "github.com/maxmcd/dag"
)

type DerivationsMap struct {
        sync.Map
}

func (dm *DerivationsMap) Load(filename string) *Derivation <span class="cov8" title="1">{
        d, ok := dm.Map.Load(filename)
        if !ok </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">return d.(*Derivation)</span>
}

func (dm *DerivationsMap) Has(filename string) bool <span class="cov0" title="0">{
        return dm.Load(filename) != nil
}</span>
func (dm *DerivationsMap) Store(filename string, drv *Derivation) <span class="cov8" title="1">{
        dm.Map.Store(filename, drv)
}</span>

// Range calls f sequentially for each key and value present in the map. If f
// returns false, range stops the iteration.
func (dm *DerivationsMap) Range(f func(filename string, drv *Derivation) bool) <span class="cov0" title="0">{
        dm.Map.Range(func(key, value interface{}) bool </span><span class="cov0" title="0">{
                return f(key.(string), value.(*Derivation))
        }</span>)
}

// FakeDAGRoot is used when we have multiple build outputs, or "roots" in our
// graph so we need to tie them to a single fake root so that we still have a
// value DAG.
const FakeDAGRoot = "fakeDAGRoot"

// AcyclicGraph
type AcyclicGraph struct {
        dag.AcyclicGraph
}

func NewAcyclicGraph() *AcyclicGraph <span class="cov8" title="1">{
        return &amp;AcyclicGraph{}
}</span>

func (ag AcyclicGraph) PrintDot() <span class="cov8" title="1">{
        graphString := string(ag.Dot(&amp;dag.DotOpts{DrawCycles: true, Verbose: true}))
        fmt.Println(strings.ReplaceAll(graphString, "\"[root] ", "\""))
}</span>

func mergeGraphs(graphs ...*AcyclicGraph) *AcyclicGraph <span class="cov8" title="1">{
        if len(graphs) == 0 </span><span class="cov0" title="0">{
                return NewAcyclicGraph()
        }</span>
        <span class="cov8" title="1">if len(graphs) == 1 </span><span class="cov8" title="1">{
                return graphs[0]
        }</span>
        <span class="cov8" title="1">out := graphs[0]
        for _, graph := range graphs[1:] </span><span class="cov8" title="1">{
                // Add all vertices and edges to the output graph
                for _, vertex := range graph.Vertices() </span><span class="cov8" title="1">{
                        out.Add(vertex)
                }</span>
                <span class="cov8" title="1">for _, edge := range graph.Edges() </span><span class="cov8" title="1">{
                        out.Connect(edge)
                }</span>
        }

        <span class="cov8" title="1">roots := graphRoots(out)
        if len(roots) != 1 </span><span class="cov8" title="1">{
                out.Add(FakeDAGRoot)
                for _, root := range roots </span><span class="cov8" title="1">{
                        if root != FakeDAGRoot </span><span class="cov8" title="1">{
                                out.Connect(dag.BasicEdge(FakeDAGRoot, root))
                        }</span>
                }
        }
        <span class="cov8" title="1">return out</span>
}

func graphRoots(g *AcyclicGraph) []dag.Vertex <span class="cov8" title="1">{
        roots := make([]dag.Vertex, 0, 1)
        for _, v := range g.Vertices() </span><span class="cov8" title="1">{
                if g.UpEdges(v).Len() == 0 </span><span class="cov8" title="1">{
                        roots = append(roots, v)
                }</span>
        }
        <span class="cov8" title="1">return roots</span>
}

type BiStringMap struct {
        s       sync.RWMutex
        forward map[string]string
        inverse map[string]string
}

// NewBiStringMap returns a an empty, mutable, BiStringMap
func NewBiStringMap() *BiStringMap <span class="cov8" title="1">{
        return &amp;BiStringMap{
                forward: make(map[string]string),
                inverse: make(map[string]string),
        }
}</span>

func (b *BiStringMap) Store(k, v string) <span class="cov8" title="1">{
        b.s.Lock()
        b.forward[k] = v
        b.inverse[v] = k
        b.s.Unlock()
}</span>

func (b *BiStringMap) Load(k string) (v string, exists bool) <span class="cov0" title="0">{
        b.s.RLock()
        v, exists = b.forward[k]
        b.s.RUnlock()
        return
}</span>

func (b *BiStringMap) StoreInverse(k, v string) <span class="cov0" title="0">{
        b.s.Lock()
        b.forward[v] = k
        b.inverse[k] = v
        b.s.Unlock()
}</span>

func (b *BiStringMap) LoadInverse(k string) (v string, exists bool) <span class="cov0" title="0">{
        b.s.RLock()
        v, exists = b.inverse[k]
        b.s.RUnlock()
        return
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">package bramble

import (
        "bytes"
        "context"
        "encoding/json"
        "fmt"
        "io/ioutil"
        "regexp"
        "runtime/trace"
        "sort"
        "strings"
        "sync"
        "time"

        "github.com/maxmcd/bramble/pkg/hasher"
        "github.com/maxmcd/bramble/pkg/logger"
        "github.com/maxmcd/bramble/pkg/starutil"
        "github.com/pkg/errors"
        "go.starlark.net/starlark"
)

var (
        BuildDirPattern = "bramble_build_directory*"

        // BramblePrefixOfRecord is the prefix we use when hashing the build output
        // this allows us to get a consistent hash even if we're building in a
        // different location
        BramblePrefixOfRecord = "/home/bramble/bramble/bramble_store_padding/bramb"

        // UnbuiltDerivationOutputTemplate is the template string we use to write
        // derivation outputs into other derivations.
        UnbuiltDerivationOutputTemplate = "{{ %s:%s }}"
        BuiltDerivationOutputTemplate   = "{{ %s }}"

        // UnbuiltTemplateStringRegexp is the regular expression that matches template strings
        // in our derivations. I assume the ".*" parts won't run away too much because
        // of the earlier match on "{{ [0-9a-z]{32}" but might be worth further
        // investigation.
        //
        // TODO: should we limit the content of the derivation name? non-latin would
        // be good for users but bad for filesystems. What's a sensible limiation
        UnbuiltTemplateStringRegexp *regexp.Regexp = regexp.MustCompile(`\{\{ ([0-9a-z]{32}-.*?\.drv):(.+?) \}\}`)
        BuiltTemplateStringRegexp   *regexp.Regexp = regexp.MustCompile(`\{\{ ([0-9a-z]{32}) \}\}`)
)

// derivationFunction is the function that creates derivations
type derivationFunction struct {
        bramble *Bramble
}

var (
        _ starlark.Value    = new(derivationFunction)
        _ starlark.Callable = new(derivationFunction)
)

func (f *derivationFunction) Freeze()               {<span class="cov0" title="0">}</span>
func (f *derivationFunction) Hash() (uint32, error) <span class="cov0" title="0">{ return 0, starutil.ErrUnhashable("module") }</span>
func (f *derivationFunction) Name() string          <span class="cov8" title="1">{ return f.String() }</span>
func (f *derivationFunction) String() string        <span class="cov8" title="1">{ return `&lt;built-in function derivation&gt;` }</span>
func (f *derivationFunction) Truth() starlark.Bool  <span class="cov0" title="0">{ return true }</span>
func (f *derivationFunction) Type() string          <span class="cov0" title="0">{ return "module" }</span>

// newDerivationFunction creates a new derivation function. When initialized this function checks if the
// bramble store exists and creates it if it does not.
func newDerivationFunction(bramble *Bramble) *derivationFunction <span class="cov8" title="1">{
        fn := &amp;derivationFunction{
                bramble: bramble,
        }
        return fn
}</span>

func isTopLevel(thread *starlark.Thread) bool <span class="cov8" title="1">{
        if thread.CallStackDepth() == 0 </span><span class="cov0" title="0">{
                // TODO: figure out what we should actually do here, so far this is
                // only for tests
                return false
        }</span>
        <span class="cov8" title="1">return thread.CallStack().At(1).Name == "&lt;toplevel&gt;"</span>
}

func (f *derivationFunction) CallInternal(thread *starlark.Thread, args starlark.Tuple, kwargs []starlark.Tuple) (v starlark.Value, err error) <span class="cov8" title="1">{
        // TODO: we should be able to cache derivation builds using some kind of hash
        // of the input values

        ctx, task := trace.NewTask(context.Background(), "derivation()")
        now := time.Now()
        defer task.End()
        if isTopLevel(thread) </span><span class="cov0" title="0">{
                return nil, errors.New("derivation call not within a function")
        }</span>
        // Parse function arguments and assemble the basic derivation
        <span class="cov8" title="1">var drv *Derivation
        drv, err = f.newDerivationFromArgs(ctx, args, kwargs)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                logger.Debugf("derivation() %s %s", time.Since(now), strings.TrimPrefix(
                        drv.sources.location, f.bramble.configLocation))
        }</span>()

        // find all source files that are used for this derivation
        <span class="cov8" title="1">if err = f.bramble.calculateDerivationInputSources(ctx, drv); err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        // Add this derivation to our internal store
        <span class="cov8" title="1">f.bramble.storeDerivation(drv)
        return drv, nil</span>
}

func (f *derivationFunction) newDerivationFromArgs(ctx context.Context, args starlark.Tuple, kwargs []starlark.Tuple) (drv *Derivation, err error) <span class="cov8" title="1">{
        region := trace.StartRegion(ctx, "newDerivationFromArgs")
        defer region.End()

        drv = &amp;Derivation{
                OutputNames: []string{"out"},
                Env:         map[string]string{},
                bramble:     f.bramble,
        }
        var (
                name      starlark.String
                builder   starlark.String
                argsParam *starlark.List
                sources   filesList
                env       *starlark.Dict
                outputs   *starlark.List
        )
        if err = starlark.UnpackArgs("derivation", args, kwargs,
                "name", &amp;name,
                "builder", &amp;builder,
                "args?", &amp;argsParam,
                "sources?", &amp;sources,
                "env?", &amp;env,
                "outputs?", &amp;outputs,
        ); err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">drv.Name = name.GoString()

        if argsParam != nil </span><span class="cov8" title="1">{
                if drv.Args, err = starutil.IterableToGoList(argsParam); err != nil </span><span class="cov0" title="0">{
                        return
                }</span>
        }
        <span class="cov8" title="1">drv.sources = sources

        if env != nil </span><span class="cov8" title="1">{
                if drv.Env, err = starutil.DictToGoStringMap(env); err != nil </span><span class="cov0" title="0">{
                        return
                }</span>
        }

        <span class="cov8" title="1">if outputs != nil </span><span class="cov8" title="1">{
                outputsList, err := starutil.IterableToGoList(outputs)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">drv.Outputs = nil
                drv.OutputNames = outputsList</span>
        }

        <span class="cov8" title="1">drv.Builder = builder.GoString()

        drv.populateUnbuiltInputDerivations()

        return drv, nil</span>
}

// Derivation is the basic building block of a Bramble build
type Derivation struct {
        // fields are in alphabetical order to attempt to provide consistency to
        // hashmap key ordering

        // Args are arguments that are passed to the builder
        Args []string
        // BuildContextSource is the source directory that
        BuildContextSource       string
        BuildContextRelativePath string
        // Builder will either be set to a string constant to signify an internal
        // builder (like "fetch_url"), or it will be set to the path of an
        // executable in the bramble store
        Builder string
        // Env are environment variables set during the build
        Env map[string]string
        // InputDerivations are derivations that are using as imports to this build, outputs
        // dependencies are tracked in the outputs
        InputDerivations DerivationOutputs
        // Name is the name of the derivation
        Name string
        // Outputs are build outputs, a derivation can have many outputs, the
        // default output is called "out". Multiple outputs are useful when your
        // build process can produce multiple artifacts, but building them as a
        // standalone derivation would involve a complete rebuild.
        //
        // This attribute is removed when hashing the derivation.
        OutputNames []string
        Outputs     []Output
        // Platform is the platform we've built this derivation on
        Platform string
        // SourcePaths are all paths that must exist to support this build
        SourcePaths []string

        // internal fields
        sources filesList
        bramble *Bramble
        lock    sync.Mutex
}

// DerivationOutput tracks the build outputs. Outputs are not included in the
// Derivation hash. The path tracks the output location in the bramble store
// and Dependencies tracks the bramble outputs that are runtime dependencies.
type Output struct {
        Path         string
        Dependencies []string
}

func (o Output) Empty() bool <span class="cov0" title="0">{
        if o.Path == "" &amp;&amp; len(o.Dependencies) == 0 </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov0" title="0">return false</span>
}

// DerivationOutput is one of the derivation inputs. Path is the location of
// the derivation, output is the name of the specific output this derivation
// uses for the build
type DerivationOutput struct {
        Filename   string
        OutputName string
}

func (do DerivationOutput) templateString() string <span class="cov0" title="0">{
        return fmt.Sprintf(UnbuiltDerivationOutputTemplate, do.Filename, do.OutputName)
}</span>

type DerivationOutputs []DerivationOutput

func (dos DerivationOutputs) Len() int      <span class="cov8" title="1">{ return len(dos) }</span>
func (dos DerivationOutputs) Swap(i, j int) <span class="cov8" title="1">{ dos[i], dos[j] = dos[j], dos[i] }</span>
func (dos DerivationOutputs) Less(i, j int) bool <span class="cov8" title="1">{
        return dos[i].Filename+dos[i].OutputName &lt; dos[j].Filename+dos[j].OutputName
}</span>

func (drv *Derivation) DerivationOutputs() (dos DerivationOutputs) <span class="cov8" title="1">{
        filename := drv.filename()
        for _, name := range drv.OutputNames </span><span class="cov8" title="1">{
                dos = append(dos, DerivationOutput{Filename: filename, OutputName: name})
        }</span>
        <span class="cov8" title="1">return</span>
}

func sortAndUniqueInputDerivations(dos DerivationOutputs) DerivationOutputs <span class="cov8" title="1">{
        // sort
        if !sort.IsSorted(dos) </span><span class="cov8" title="1">{
                sort.Sort(dos)
        }</span>
        <span class="cov8" title="1">if len(dos) == 0 </span><span class="cov8" title="1">{
                return dos
        }</span>

        // dedupe
        <span class="cov8" title="1">j := 0
        for i := 1; i &lt; len(dos); i++ </span><span class="cov8" title="1">{
                if dos[j] == dos[i] </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">j++
                dos[j] = dos[i]</span>
        }
        <span class="cov8" title="1">return dos[:j+1]</span>
}

var (
        _ starlark.Value    = new(Derivation)
        _ starlark.HasAttrs = new(Derivation)
)

func (drv *Derivation) Freeze()               {<span class="cov0" title="0">}</span>
func (drv *Derivation) Hash() (uint32, error) <span class="cov0" title="0">{ return 0, starutil.ErrUnhashable("cmd") }</span>
func (drv *Derivation) Truth() starlark.Bool  <span class="cov0" title="0">{ return starlark.True }</span>
func (drv *Derivation) Type() string          <span class="cov8" title="1">{ return "derivation" }</span>

func (drv *Derivation) String() string <span class="cov8" title="1">{
        return drv.templateString(drv.mainOutput())
}</span>

func (drv *Derivation) Attr(name string) (val starlark.Value, err error) <span class="cov8" title="1">{
        if !drv.HasOutput(name) </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov8" title="1">return starlark.String(
                drv.templateString(name),
        ), nil</span>
}

func (drv *Derivation) AttrNames() (out []string) <span class="cov0" title="0">{
        return drv.OutputNames
}</span>

func (drv *Derivation) MissingOutput() bool <span class="cov8" title="1">{
        if len(drv.Outputs) == 0 </span><span class="cov8" title="1">{
                return true
        }</span>
        <span class="cov8" title="1">for _, v := range drv.Outputs </span><span class="cov8" title="1">{
                if v.Path == "" </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

func (drv *Derivation) HasOutput(name string) bool <span class="cov8" title="1">{
        for _, o := range drv.OutputNames </span><span class="cov8" title="1">{
                if o == name </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

func (drv *Derivation) Output(name string) Output <span class="cov8" title="1">{
        for i, o := range drv.OutputNames </span><span class="cov8" title="1">{
                if o == name </span><span class="cov8" title="1">{
                        if len(drv.Outputs) &gt; i </span><span class="cov8" title="1">{
                                return drv.Outputs[i]
                        }</span>
                }
        }
        <span class="cov8" title="1">return Output{}</span>
}

func (drv *Derivation) SetOutput(name string, o Output) <span class="cov8" title="1">{
        for i, on := range drv.OutputNames </span><span class="cov8" title="1">{
                if on == name </span><span class="cov8" title="1">{
                        // grow if we need to
                        for len(drv.Outputs) &lt;= i </span><span class="cov8" title="1">{
                                drv.Outputs = append(drv.Outputs, Output{})
                        }</span>
                        <span class="cov8" title="1">drv.Outputs[i] = o
                        return</span>
                }
        }
        // TODO
        <span class="cov0" title="0">panic("unable to set output with name: " + name)</span>
}

func (drv *Derivation) templateString(output string) string <span class="cov8" title="1">{
        outputPath := drv.Output(output).Path
        if drv.Output(output).Path != "" </span><span class="cov8" title="1">{
                return fmt.Sprintf(BuiltDerivationOutputTemplate, outputPath)
        }</span>
        <span class="cov8" title="1">fn := drv.filename()
        return fmt.Sprintf(UnbuiltDerivationOutputTemplate, fn, output)</span>
}

func (drv *Derivation) mainOutput() string <span class="cov8" title="1">{
        if out := drv.Output("out"); out.Path != "" || len(drv.OutputNames) == 0 </span><span class="cov8" title="1">{
                return "out"
        }</span>
        <span class="cov8" title="1">return drv.OutputNames[0]</span>
}

func (drv *Derivation) env() (env []string) <span class="cov8" title="1">{
        for k, v := range drv.Env </span><span class="cov8" title="1">{
                env = append(env, fmt.Sprintf("%s=%s", k, v))
        }</span>
        <span class="cov8" title="1">return</span>
}

func (drv *Derivation) PrettyJSON() string <span class="cov8" title="1">{
        drv.makeConsistentNullJSONValues()
        b, _ := json.MarshalIndent(drv, "", "  ")
        return string(b)
}</span>

// populateUnbuiltInputDerivations matches on the derivation input template and
// adds those candidates to the inputderivations
func (drv *Derivation) populateUnbuiltInputDerivations() <span class="cov8" title="1">{
        drv.InputDerivations = drv._matchedUnbuiltDerivationInputs()
}</span>

func (drv *Derivation) _matchedUnbuiltDerivationInputs() DerivationOutputs <span class="cov8" title="1">{
        s := string(drv.JSON())
        out := DerivationOutputs{}
        for _, match := range UnbuiltTemplateStringRegexp.FindAllStringSubmatch(s, -1) </span><span class="cov8" title="1">{
                // We must validate that the derivation exists and this isn't just an
                // errant template string
                if drv.bramble.derivations.Load(match[1]) != nil </span><span class="cov8" title="1">{
                        out = append(out, DerivationOutput{
                                Filename:   match[1],
                                OutputName: match[2],
                        })
                }</span>
        }
        <span class="cov8" title="1">return sortAndUniqueInputDerivations(out)</span>
}

func (drv *Derivation) containsUnbuiltDerivationTemplateStrings() bool <span class="cov0" title="0">{
        return len(drv._matchedUnbuiltDerivationInputs()) &gt; 0
}</span>

func (drv *Derivation) makeConsistentNullJSONValues() <span class="cov8" title="1">{
        if len(drv.Args) == 0 </span><span class="cov8" title="1">{
                drv.Args = nil
        }</span>
        <span class="cov8" title="1">if len(drv.Env) == 0 </span><span class="cov0" title="0">{
                drv.Env = nil
        }</span>
        <span class="cov8" title="1">if len(drv.OutputNames) == 0 </span><span class="cov0" title="0">{
                drv.OutputNames = nil
        }</span>
        <span class="cov8" title="1">if len(drv.Outputs) == 0 </span><span class="cov8" title="1">{
                drv.Outputs = nil
        }</span>
        <span class="cov8" title="1">if len(drv.SourcePaths) == 0 </span><span class="cov8" title="1">{
                drv.SourcePaths = nil
        }</span>
        <span class="cov8" title="1">if len(drv.InputDerivations) == 0 </span><span class="cov8" title="1">{
                drv.InputDerivations = nil
        }</span>
}

func (drv *Derivation) JSON() []byte <span class="cov8" title="1">{
        drv.makeConsistentNullJSONValues()
        b, err := json.Marshal(drv)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span> // Shouldn't ever happen
        }
        <span class="cov8" title="1">return b</span>
}

func (drv *Derivation) filename() (filename string) <span class="cov8" title="1">{
        // Content is hashed without derivation outputs.
        outputs := drv.Outputs
        drv.Outputs = nil
        jsonBytesForHashing := drv.JSON()
        drv.Outputs = outputs

        fileName := fmt.Sprintf("%s.drv", drv.Name)
        _, filename, err := hasher.HashFile(fileName, ioutil.NopCloser(bytes.NewBuffer(jsonBytesForHashing)))
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span> // shouldn't ever happen
        }
        <span class="cov8" title="1">return</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package bramble

import (
        "archive/tar"
        "bytes"
        "context"
        "fmt"
        "io"
        "io/ioutil"
        "math/rand"
        "os"
        "path/filepath"
        "runtime/trace"
        "time"

        docker "github.com/fsouza/go-dockerclient"
        "github.com/maxmcd/bramble/pkg/hasher"
        "github.com/pkg/errors"
)

var (
        DockerScratchImageName        = "bramble-scratch"
        DockerBramblePathVolumePrefix = "bramble-path-"
)

// TODO: Should be able to download a version of the bramble executable for a specific
// version. The version should be in the derivation and the software should be able to download
// various versions of the software to ensure that it's running starlark within the container correctly
// the bramble binary should be staticly compiled and referenced by hash. We hash the binary and write the
// hash to itself just like we patch our build outputs. The hash should be baked into the binary at compile
// time.
//
// If there isn't a bramble hash or version available we should lookPath at the current environment
// and copy that bramble version into the build. For darwin/windows we might need to reference a
// know location outside of the container or trigger a cross-build or, hmm... something.

type runDockerBuildOptions struct {
        buildDir    string
        outputPaths map[string]string

        stdin io.Reader

        mountBrambleBinary bool
        workingDir         string
        cmd                []string
        env                []string
}

func ensureBrambleVolume(volumeName string, client *docker.Client) (err error) <span class="cov0" title="0">{
        volumes, err := client.ListVolumes(docker.ListVolumesOptions{
                Filters: map[string][]string{"name": {volumeName}},
        })
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if len(volumes) &gt; 0 </span><span class="cov0" title="0">{ // add labels when creating and check them here as a fallback on name collisions
                return nil
        }</span>

        <span class="cov0" title="0">_, err = client.CreateVolume(docker.CreateVolumeOptions{Name: volumeName})
        return err</span>
}

func ensureBrambleScratchImage(client *docker.Client) (err error) <span class="cov0" title="0">{
        images, err := client.ListImages(docker.ListImagesOptions{
                Filter: DockerScratchImageName,
        })
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if len(images) &gt; 0 &amp;&amp; images[0].Size == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Build scratch image if we don't have it
        <span class="cov0" title="0">buf := bytes.NewBuffer(nil)
        dockerfileContents := "FROM scratch\nCMD nothing"
        tarWriter := tar.NewWriter(buf)
        if err = tarWriter.WriteHeader(&amp;tar.Header{
                Name: "Dockerfile",
                Size: int64(len(dockerfileContents)),
        }); err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">if _, err = tarWriter.Write([]byte(dockerfileContents)); err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">if err = tarWriter.Close(); err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">if err := client.BuildImage(docker.BuildImageOptions{
                Name:         DockerScratchImageName,
                InputStream:  buf,
                OutputStream: ioutil.Discard,
        }); err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "error building bramble-scratch")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (b *Bramble) runDockerBuild(ctx context.Context, name string, options runDockerBuildOptions) (err error) <span class="cov0" title="0">{
        var task *trace.Task
        ctx, task = trace.NewTask(ctx, "runDockerBuild")
        defer task.End()

        client, err := docker.NewClientFromEnv()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if options.buildDir == "" </span><span class="cov0" title="0">{
                return errors.New("must include a build directory")
        }</span>
        <span class="cov0" title="0">if len(options.outputPaths) == 0 </span><span class="cov0" title="0">{
                return errors.New("must include output paths")
        }</span>

        <span class="cov0" title="0">volumeName := DockerBramblePathVolumePrefix + hasher.HashString(b.store.BramblePath)
        if err = ensureBrambleVolume(volumeName, client); err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">binds := []string{
                // mount the entire store path as a ready-only volume
                fmt.Sprintf("%s:%s:ro", b.store.StorePath, b.store.StorePath),
                fmt.Sprintf("%s:%s", // volume mount the build directory
                        options.buildDir,
                        options.buildDir,
                ),
        }
        user := fmt.Sprintf("%d:%d", os.Getuid(), os.Getgid())
        if _, ok := os.LookupEnv("BRAMBLE_WITHIN_DOCKER"); ok </span><span class="cov0" title="0">{
                user = fmt.Sprintf("%s:%s", os.Getenv("BRAMBLE_SET_UID"), os.Getenv("BRAMBLE_SET_GID"))
                binds = []string{
                        fmt.Sprintf("%s:%s", volumeName, b.store.BramblePath),
                        // Mount the project that we're in
                        fmt.Sprintf("%s:%s",
                                b.configLocation,
                                b.configLocation),
                }
                options.env = append(options.env, "BRAMBLE_WITHIN_DOCKER=1")
        }</span> else<span class="cov0" title="0"> {
                for _, outputPath := range options.outputPaths </span><span class="cov0" title="0">{
                        binds = append(binds, fmt.Sprintf("%s:%s", // volume mount all output directories
                                outputPath,
                                outputPath,
                        ))
                }</span>
        }

        <span class="cov0" title="0">if options.mountBrambleBinary </span><span class="cov0" title="0">{
                // TODO: replace with symlink to store path of the specific bramble
                // version we want
                // TODO: deprecated
                binds = append(binds, fmt.Sprintf("%s:%s", // bring in a version of bramble
                        filepath.Join(b.store.BramblePath, "var/linux-binary"),
                        "/bin/bramble",
                ))
        }</span>

        <span class="cov0" title="0">if err = ensureBrambleScratchImage(client); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">hasStdin := options.stdin != nil

        // TODO: remove when done developing this feature
        _ = client.RemoveContainer(docker.RemoveContainerOptions{ID: name, Force: true})

        region := trace.StartRegion(ctx, "createContainer")
        defer func() </span><span class="cov0" title="0">{ region.End() }</span>()
        <span class="cov0" title="0">cont, err := client.CreateContainer(docker.CreateContainerOptions{
                Name: name,
                Config: &amp;docker.Config{
                        User:            user,
                        NetworkDisabled: true,

                        Image:      "bramble-scratch",
                        Cmd:        options.cmd,
                        Env:        options.env,
                        WorkingDir: options.workingDir,

                        AttachStderr: true,
                        AttachStdout: true,
                        Tty:          false,

                        AttachStdin: hasStdin,
                        OpenStdin:   hasStdin,
                        StdinOnce:   hasStdin,
                },
                HostConfig: &amp;docker.HostConfig{
                        Binds: binds,
                },
                Context: ctx,
        })
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "error creating container")
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                er := client.RemoveContainer(docker.RemoveContainerOptions{
                        ID: cont.ID,
                })
                if err == nil &amp;&amp; er != nil </span><span class="cov0" title="0">{
                        err = er
                }</span>
        }()
        <span class="cov0" title="0">region.End()
        region = trace.StartRegion(ctx, "attachToContainer")
        _, err = client.AttachToContainerNonBlocking(docker.AttachToContainerOptions{
                Container:    cont.ID,
                Stderr:       true,
                Stdout:       true,
                RawTerminal:  false,
                Stream:       true,
                OutputStream: os.Stdout,
                ErrorStream:  os.Stderr,

                Stdin:       hasStdin,
                InputStream: options.stdin,
        })
        if err != nil </span><span class="cov0" title="0">{
                err = errors.Wrap(err, "error attaching to container")
                return
        }</span>

        <span class="cov0" title="0">region.End()
        region = trace.StartRegion(ctx, "containerStarted")
        if err = client.StartContainer(cont.ID, nil); err != nil </span><span class="cov0" title="0">{
                err = errors.Wrap(err, "error starting container")
                return
        }</span>

        <span class="cov0" title="0">if _, err = client.WaitContainerWithContext(cont.ID, ctx); err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">if cont, err = client.InspectContainerWithOptions(docker.InspectContainerOptions{
                ID: cont.ID,
        }); err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">if cont.State.Running </span><span class="cov0" title="0">{
                err = errors.New("build container is still running")
                return
        }</span>
        <span class="cov0" title="0">if cont.State.ExitCode != 0 </span><span class="cov0" title="0">{
                err = errors.Errorf("got container exit code %d", cont.State.ExitCode)
                return
        }</span>
        <span class="cov0" title="0">return</span>
}

func dockerRunName() string <span class="cov0" title="0">{
        rand.Seed(time.Now().UnixNano())
        return fmt.Sprintf("bramble-run-%d", rand.Int())
}</span>

func (b *Bramble) runDockerRun(ctx context.Context, args []string) (err error) <span class="cov0" title="0">{
        var task *trace.Task
        ctx, task = trace.NewTask(ctx, "runDockerRun")
        defer task.End()
        name := dockerRunName()

        client, err := docker.NewClientFromEnv()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">volumeName := DockerBramblePathVolumePrefix + hasher.HashString(b.store.BramblePath)
        if err = ensureBrambleVolume(volumeName, client); err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">if err = ensureBrambleScratchImage(client); err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">binds := []string{
                // mount the bramble path
                // we use the hosts bramble path here as a convenience so that we don't have
                // to rewrite paths
                fmt.Sprintf("%s:%s", volumeName, b.store.BramblePath),

                // bring in a version of bramble
                // TODO: deprecated
                fmt.Sprintf("%s:%s",
                        filepath.Join(b.store.BramblePath, "var/linux-binary"),
                        "/bin/bramble"),

                // Mount the project that we're in
                fmt.Sprintf("%s:%s",
                        b.configLocation,
                        b.configLocation),

                // pass in the docker sock. this wouldn't support connecting to docker
                // machines, might want to think about supporting that... (TODO)
                "/var/run/docker.sock:/var/run/docker.sock",
        }

        // pass the host environment
        env := []string{}
        // make sure we use the bramble path that we've mounted
        env = append(env, "BRAMBLE_PATH="+b.store.BramblePath)
        env = append(env, fmt.Sprintf("BRAMBLE_SET_UID=%d", os.Geteuid()))
        env = append(env, fmt.Sprintf("BRAMBLE_SET_GID=%d", os.Getegid()))
        env = append(env, "BRAMBLE_WITHIN_DOCKER=1")

        cmd := append([]string{"/bin/bramble"}, args...)

        wd, err := os.Getwd()
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "getting working directory for docker container")
        }</span>

        <span class="cov0" title="0">region := trace.StartRegion(ctx, "createContainer")
        defer func() </span><span class="cov0" title="0">{ region.End() }</span>()
        <span class="cov0" title="0">cont, err := client.CreateContainer(docker.CreateContainerOptions{
                Name: name,
                Config: &amp;docker.Config{
                        NetworkDisabled: false,

                        // We don't set the user. We start as root and the process
                        // calls setuid/setguid
                        // User: fmt.Sprintf("%d:%d", os.Getuid(), os.Getgid()),

                        Image: "bramble-scratch",
                        Cmd:   cmd,
                        Env:   env,

                        WorkingDir: wd,

                        AttachStderr: true,
                        AttachStdout: true,

                        // TODO: yes when we have one, no when we don't
                        Tty: false,

                        AttachStdin: true,
                        OpenStdin:   true,
                        StdinOnce:   true,
                },
                HostConfig: &amp;docker.HostConfig{
                        Binds: binds,
                },
                Context: ctx,
        })
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "error creating container")
        }</span>

        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                er := client.RemoveContainer(docker.RemoveContainerOptions{
                        ID: cont.ID,
                })
                if err == nil &amp;&amp; er != nil </span><span class="cov0" title="0">{
                        err = er
                }</span>
        }()

        <span class="cov0" title="0">region.End()
        region = trace.StartRegion(ctx, "attachToContainer")
        _, err = client.AttachToContainerNonBlocking(docker.AttachToContainerOptions{
                Container:    cont.ID,
                Stdout:       true,
                Stderr:       true,
                Stdin:        true,
                RawTerminal:  false,
                Stream:       true,
                OutputStream: os.Stdout,
                ErrorStream:  os.Stderr,
                InputStream:  os.Stdin,
        })
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "error attaching to container")
        }</span>
        <span class="cov0" title="0">region.End()
        region = trace.StartRegion(ctx, "containerStarted")
        if err = client.StartContainer(cont.ID, nil); err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "error starting container")
        }</span>

        <span class="cov0" title="0">if _, err := client.WaitContainerWithContext(cont.ID, ctx); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if cont, err = client.InspectContainerWithOptions(docker.InspectContainerOptions{
                ID: cont.ID,
        }); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if cont.State.Running </span><span class="cov0" title="0">{
                return errors.New("run container is still running")
        }</span>
        <span class="cov0" title="0">if cont.State.ExitCode != 0 </span><span class="cov0" title="0">{
                return errors.Errorf("got container exit code %d", cont.State.ExitCode)
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package bramble

import (
        "fmt"

        "github.com/pkg/errors"
)

var (
        errQuiet        = errors.New("")
        ErrNotInProject = errors.New("couldn't find a bramble.toml file in this directory or any parent")
)

type errModuleDoesNotExist string

func (err errModuleDoesNotExist) Error() string <span class="cov0" title="0">{
        // TODO: this error is confusing because we can find the module we just
        // can't find the file needed to run/import this specific module path
        return fmt.Sprintf("couldn't find module %q", string(err))
}</span>
</pre>
		
		<pre class="file" id="file10" style="display: none">package bramble

import (
        "fmt"
        "io/fs"
        "os"
        "path/filepath"
        "strings"

        "github.com/bmatcuk/doublestar/v4"
        "github.com/maxmcd/bramble/pkg/starutil"
        "github.com/pkg/errors"
        "go.starlark.net/starlark"
)

type filesList struct {
        files    []string
        location string
}

var _ starlark.Value = new(filesList)

func (fl filesList) Freeze()               {<span class="cov0" title="0">}</span>
func (fl filesList) Hash() (uint32, error) <span class="cov0" title="0">{ return 0, starutil.ErrUnhashable("file_list") }</span>
func (fl filesList) String() string        <span class="cov0" title="0">{ return fmt.Sprint([]string(fl.files)) }</span>
func (fl filesList) Type() string          <span class="cov0" title="0">{ return "file_list" }</span>
func (fl filesList) Truth() starlark.Bool  <span class="cov0" title="0">{ return true }</span>

func (b *Bramble) starlarkGlobListFiles(includeDirectories bool, fileDirectory string, list *starlark.List) (map[string]struct{}, error) <span class="cov8" title="1">{
        projFilesystem := os.DirFS(b.configLocation)
        out := map[string]struct{}{}
        for _, glob := range starutil.ListToValueList(list) </span><span class="cov8" title="1">{
                s, ok := glob.(starlark.String)
                if !ok </span><span class="cov0" title="0">{
                        return nil, errors.Errorf("files argument %q is not a string", glob)
                }</span>
                <span class="cov8" title="1">strValue := string(s)

                if filepath.IsAbs(strValue) </span><span class="cov0" title="0">{
                        return nil, errors.Errorf("argument %q is an absolute path", strValue)
                }</span>

                <span class="cov8" title="1">searchGlob := filepath.Join(fileDirectory, strValue)
                searchGlob, err := filepath.Rel(b.configLocation, searchGlob)
                if err != nil || strings.Contains(searchGlob, "..") </span><span class="cov0" title="0">{
                        return nil, errors.Errorf("file search path %q searches outside of the project directory", strValue)
                }</span>
                <span class="cov8" title="1">if err := doublestar.GlobWalk(
                        projFilesystem,
                        searchGlob,
                        func(path string, d fs.DirEntry) error </span><span class="cov8" title="1">{
                                // Skip directories if we want
                                if !bool(includeDirectories) &amp;&amp; d.IsDir() </span><span class="cov0" title="0">{
                                        return nil
                                }</span>
                                <span class="cov8" title="1">out[path] = struct{}{}
                                return nil</span>
                        }); err != nil <span class="cov0" title="0">{
                        return nil, errors.Wrapf(err, "error with pattern %q", strValue)
                }</span>
        }
        <span class="cov8" title="1">return out, nil</span>
}
func (b *Bramble) filesBuiltin(thread *starlark.Thread, fn *starlark.Builtin, args starlark.Tuple, kwargs []starlark.Tuple) (out starlark.Value, err error) <span class="cov8" title="1">{
        var (
                include            *starlark.List
                exclude            *starlark.List
                includeDirectories starlark.Bool
                allowEmpty         starlark.Bool
        )

        if err = starlark.UnpackArgs("files", args, kwargs,
                "include", &amp;include,
                "exclude?", &amp;exclude,
                "include_directories?", &amp;includeDirectories,
                "allow_empty?", &amp;allowEmpty,
        ); err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        // get location of file where files() is being called
        <span class="cov8" title="1">file := thread.CallStack().At(1).Pos.Filename()
        fileDirectory := filepath.Dir(file)

        inclSet, err := b.starlarkGlobListFiles(bool(includeDirectories), fileDirectory, include)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">exclSet := map[string]struct{}{}
        if exclude != nil </span><span class="cov0" title="0">{
                if exclSet, err = b.starlarkGlobListFiles(bool(includeDirectories), fileDirectory, exclude); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        <span class="cov8" title="1">fl := filesList{
                location: fileDirectory,
        }
        for f := range inclSet </span><span class="cov8" title="1">{
                if _, match := exclSet[f]; !match </span><span class="cov8" title="1">{
                        fl.files = append(fl.files, f)
                }</span>
        }
        <span class="cov8" title="1">if len(fl.files) == 0 &amp;&amp; !allowEmpty </span><span class="cov0" title="0">{
                return nil, errors.New("files() call matched zero files")
        }</span>

        <span class="cov8" title="1">return fl, nil</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package main

import (
        "log"

        "github.com/maxmcd/bramble/pkg/sandbox"
)

func main() <span class="cov0" title="0">{
        sandbox.Entrypoint()
        // This shouldn't be reachable unless the entrypoint didn't run
        log.Fatal("can't run bramble-setuid without correct arguments")
}</span>
</pre>
		
		<pre class="file" id="file12" style="display: none">package main

import (
        "context"
        "log"
        "os"
        "time"

        "github.com/containerd/console"
        "github.com/maxmcd/bramble/pkg/progressui"
)

func main() <span class="cov0" title="0">{
        current := console.Current()

        input := make(chan *progressui.SolveStatus)
        go func() </span><span class="cov0" title="0">{
                n := time.Now()
                input &lt;- &amp;progressui.SolveStatus{
                        Vertexes: []*progressui.Vertex{{
                                Digest:  "hi",
                                Name:    "foo",
                                Started: &amp;n,
                        }},
                        Statuses: []*progressui.VertexStatus{{
                                ID:      "yes",
                                Vertex:  "hi",
                                Name:    "hellooo",
                                Total:   123,
                                Current: 1,
                        }},
                        Logs: []*progressui.VertexLog{{
                                Vertex:    "hif",
                                Data:      []byte("I did!"),
                                Timestamp: time.Now(),
                        }},
                }
                input &lt;- &amp;progressui.SolveStatus{
                        Statuses: []*progressui.VertexStatus{{
                                Vertex: "hi",
                                Name:   "hellooo",
                        }},
                        Logs: []*progressui.VertexLog{{
                                Vertex:    "hi",
                                Data:      []byte("I did!"),
                                Timestamp: time.Now(),
                        }},
                }
        }</span>()
        <span class="cov0" title="0">log.Fatal(progressui.DisplaySolveStatus(context.Background(), "ok", current, os.Stdout, input))</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package main

import (
        "errors"
        "fmt"
        "io"
        "os"
        "strings"

        "github.com/maxmcd/bramble/pkg/reptar"
)

func main() <span class="cov0" title="0">{
        if err := run(os.Args); err != nil </span><span class="cov0" title="0">{
                fmt.Println(err)
                os.Exit(1)
        }</span>
}

func run(args []string) error <span class="cov0" title="0">{
        if len(args) &lt; 3 </span><span class="cov0" title="0">{
                return errors.New("reptar is run like: reptar outputfile.tar.gz ./files-to-package")
        }</span>

        <span class="cov0" title="0">var fn func(a string, b io.Writer) error

        switch </span>{
        case strings.HasSuffix(args[1], ".tar"):<span class="cov0" title="0">
                fn = reptar.Reptar</span>
        case strings.HasSuffix(args[1], ".tar.gz"):<span class="cov0" title="0">
                fn = reptar.GzipReptar</span>
        default:<span class="cov0" title="0">
                return errors.New("archive name must end in .tar or .tar.gz")</span>
        }

        <span class="cov0" title="0">f, err := os.Create(args[1])
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer f.Close()

        return fn(args[2], f)</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package fileutil

import (
        "fmt"
        "io"
        "io/ioutil"
        "log"
        "os"
        "os/exec"
        "path"
        "path/filepath"
        "sort"
        "strings"
        "syscall"
        "testing"

        "github.com/pkg/errors"
)

func CommonFilepathPrefix(paths []string) string <span class="cov8" title="1">{
        sep := byte(os.PathSeparator)
        if len(paths) == 0 </span><span class="cov0" title="0">{
                return string(sep)
        }</span>

        <span class="cov8" title="1">c := []byte(path.Clean(paths[0]))
        c = append(c, sep)

        for _, v := range paths[1:] </span><span class="cov8" title="1">{
                v = path.Clean(v) + string(sep)
                if len(v) &lt; len(c) </span><span class="cov8" title="1">{
                        c = c[:len(v)]
                }</span>
                <span class="cov8" title="1">for i := 0; i &lt; len(c); i++ </span><span class="cov8" title="1">{
                        if v[i] != c[i] </span><span class="cov0" title="0">{
                                c = c[:i]
                                break</span>
                        }
                }
        }

        <span class="cov8" title="1">for i := len(c) - 1; i &gt;= 0; i-- </span><span class="cov8" title="1">{
                if c[i] == sep </span><span class="cov8" title="1">{
                        c = c[:i+1]
                        break</span>
                }
        }

        <span class="cov8" title="1">return string(c)</span>
}

func CP(wd string, paths ...string) (err error) <span class="cov0" title="0">{
        if len(paths) == 1 </span><span class="cov0" title="0">{
                return errors.New("copy takes at least two arguments")
        }</span>
        <span class="cov0" title="0">absPaths := make([]string, 0, len(paths))
        for _, path := range paths </span><span class="cov0" title="0">{
                if !filepath.IsAbs(path) </span><span class="cov0" title="0">{
                        absPaths = append(absPaths, filepath.Join(wd, path))
                }</span> else<span class="cov0" title="0"> {
                        absPaths = append(absPaths, path)
                }</span>
        }
        <span class="cov0" title="0">dest := absPaths[len(paths)-1]
        // if dest exists and it's not a directory
        if FileExists(dest) </span><span class="cov0" title="0">{
                return errors.New("copy destination can't be a file that exists")
        }</span>

        <span class="cov0" title="0">toCopy := absPaths[:len(absPaths)-1]

        // "cp foo.txt bar.txt" or "cp ./foo ./bar" is a special case if it's just two
        // paths and they don't exist yet
        if len(toCopy) == 1 &amp;&amp; !PathExists(dest) </span><span class="cov0" title="0">{
                f := toCopy[0]
                if IsDir(f) </span><span class="cov0" title="0">{
                        return errors.WithStack(CopyDirectory(f, dest))
                }</span>
                <span class="cov0" title="0">return errors.WithStack(CopyFile(f, dest))</span>
        }

        // otherwise copy each listed file into a directory with the given name
        <span class="cov0" title="0">for i, path := range toCopy </span><span class="cov0" title="0">{
                fi, err := os.Stat(path)
                if err != nil </span><span class="cov0" title="0">{
                        return errors.Errorf("%q doesn't exist", paths[i])
                }</span>
                <span class="cov0" title="0">if fi.IsDir() </span><span class="cov0" title="0">{
                        destFolder := filepath.Join(dest, fi.Name())
                        if err = CreateDirIfNotExists(destFolder, 0755); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">err = CopyDirectory(path, filepath.Join(dest, fi.Name()))</span>
                } else<span class="cov0" title="0"> {
                        err = CopyFile(path, filepath.Join(dest, fi.Name()))
                }</span>
                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        return errors.WithStack(err)
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// copy directory will copy all of the contents of one directory into another directory
func CopyDirectory(scrDir, dest string) error <span class="cov8" title="1">{
        entries, err := ioutil.ReadDir(scrDir)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">for _, entry := range entries </span><span class="cov8" title="1">{
                sourcePath := filepath.Join(scrDir, entry.Name())
                destPath := filepath.Join(dest, entry.Name())

                fileInfo, err := os.Stat(sourcePath)
                if err != nil </span><span class="cov0" title="0">{
                        return errors.WithStack(err)
                }</span>

                <span class="cov8" title="1">stat, ok := fileInfo.Sys().(*syscall.Stat_t)
                _ = stat
                if !ok </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to get raw syscall.Stat_t data for '%s'", sourcePath)
                }</span>

                <span class="cov8" title="1">switch fileInfo.Mode() &amp; os.ModeType </span>{
                case os.ModeDir:<span class="cov8" title="1">
                        if err := CreateDirIfNotExists(destPath, 0755); err != nil </span><span class="cov0" title="0">{
                                return errors.WithStack(err)
                        }</span>
                        <span class="cov8" title="1">if err := CopyDirectory(sourcePath, destPath); err != nil </span><span class="cov0" title="0">{
                                return errors.WithStack(err)
                        }</span>
                case os.ModeSymlink:<span class="cov0" title="0">
                        if err := CopySymLink(sourcePath, destPath); err != nil </span><span class="cov0" title="0">{
                                return errors.WithStack(err)
                        }</span>
                default:<span class="cov8" title="1">
                        if err := CopyFile(sourcePath, destPath); err != nil </span><span class="cov0" title="0">{
                                return errors.WithStack(err)
                        }</span>
                }

                // if err := os.Lchown(destPath, int(stat.Uid), int(stat.Gid)); err != nil {
                //         return errors.WithStack(err)
                // }

                <span class="cov8" title="1">isSymlink := entry.Mode()&amp;os.ModeSymlink != 0
                if !isSymlink </span><span class="cov8" title="1">{
                        if err := os.Chmod(destPath, entry.Mode()); err != nil </span><span class="cov0" title="0">{
                                return errors.WithStack(err)
                        }</span>
                }
        }
        <span class="cov8" title="1">return nil</span>
}

// TODO: combine the duplicate logic in these two

// CopyFiles takes a list of absolute paths to files and copies them into
// another directory, maintaining structure. Importantly it doesn't copy
// all the files in these directories, just the specific named paths.
func CopyFilesByPath(prefix string, files []string, dest string) (err error) <span class="cov8" title="1">{
        files, err = ExpandPathDirectories(files)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">sort.Slice(files, func(i, j int) bool </span><span class="cov0" title="0">{ return len(files[i]) &lt; len(files[j]) }</span>)
        <span class="cov8" title="1">for _, file := range files </span><span class="cov8" title="1">{
                destPath := filepath.Join(dest, strings.TrimPrefix(file, prefix))
                fileInfo, err := os.Stat(file)
                if err != nil </span><span class="cov0" title="0">{
                        return errors.Wrap(err, "error finding source file")
                }</span>

                <span class="cov8" title="1">stat, ok := fileInfo.Sys().(*syscall.Stat_t)
                if !ok </span><span class="cov0" title="0">{
                        return errors.Errorf("failed to get raw syscall.Stat_t data for '%s'", file)
                }</span>

                <span class="cov8" title="1">switch fileInfo.Mode() &amp; os.ModeType </span>{
                case os.ModeDir:<span class="cov0" title="0">
                        if err := CreateDirIfNotExists(destPath, 0755); err != nil </span><span class="cov0" title="0">{
                                return errors.WithStack(err)
                        }</span>
                case os.ModeSymlink:<span class="cov0" title="0">
                        if err := CopySymLink(file, destPath); err != nil </span><span class="cov0" title="0">{
                                return errors.WithStack(err)
                        }</span>
                default:<span class="cov8" title="1">
                        if err := CopyFile(file, destPath); err != nil </span><span class="cov0" title="0">{
                                return errors.WithStack(err)
                        }</span>
                }

                <span class="cov8" title="1">if err := os.Lchown(destPath, int(stat.Uid), int(stat.Gid)); err != nil </span><span class="cov0" title="0">{
                        return errors.WithStack(err)
                }</span>

                // TODO: when does this happen???
                <span class="cov8" title="1">isSymlink := fileInfo.Mode()&amp;os.ModeSymlink != 0
                if !isSymlink </span><span class="cov8" title="1">{
                        if err := os.Chmod(destPath, fileInfo.Mode()); err != nil </span><span class="cov0" title="0">{
                                return errors.WithStack(err)
                        }</span>
                }
        }
        <span class="cov8" title="1">return</span>
}

// takes a list of paths and adds all files in all subdirectories
func ExpandPathDirectories(files []string) (out []string, err error) <span class="cov8" title="1">{
        for _, file := range files </span><span class="cov8" title="1">{
                if err = filepath.Walk(file,
                        func(path string, info os.FileInfo, err error) error </span><span class="cov8" title="1">{
                                if err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                                <span class="cov8" title="1">out = append(out, path)
                                return nil</span>
                        }); err != nil <span class="cov0" title="0">{
                        return
                }</span>
        }
        <span class="cov8" title="1">return</span>
}

func CopyFile(srcFile, dstFile string) error <span class="cov8" title="1">{
        in, err := os.Open(srcFile)
        if err != nil </span><span class="cov0" title="0">{
                return errors.WithStack(err)
        }</span>
        <span class="cov8" title="1">defer in.Close()

        fi, err := in.Stat()
        if err != nil </span><span class="cov0" title="0">{
                return errors.WithStack(err)
        }</span>
        <span class="cov8" title="1">out, err := os.OpenFile(dstFile, os.O_CREATE|os.O_RDWR, fi.Mode())
        if err != nil </span><span class="cov0" title="0">{
                return errors.WithStack(err)
        }</span>

        <span class="cov8" title="1">defer out.Close()

        _, err = io.Copy(out, in)
        if err != nil </span><span class="cov0" title="0">{
                return errors.WithStack(err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func CreateDirIfNotExists(dir string, perm os.FileMode) error <span class="cov8" title="1">{
        if PathExists(dir) </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">if err := os.MkdirAll(dir, perm); err != nil </span><span class="cov0" title="0">{
                return errors.Errorf("failed to create directory: '%s', error: '%s'", dir, err.Error())
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func CopySymLink(source, dest string) error <span class="cov0" title="0">{
        link, err := os.Readlink(source)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return os.Symlink(link, dest)</span>
}

// FileExists will only return true if the path is a file, not a directory
func FileExists(path string) bool <span class="cov8" title="1">{
        fi, err := os.Stat(path)
        if err != nil </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">return !fi.IsDir()</span>
}

func IsDir(file string) bool <span class="cov0" title="0">{
        info, err := os.Stat(file)
        if err != nil </span><span class="cov0" title="0">{
                if err.(*os.PathError).Err != syscall.ENOENT </span><span class="cov0" title="0">{
                        log.Fatalf("%s failed to access %s", err, file)
                }</span>
                <span class="cov0" title="0">return false</span>
        }
        <span class="cov0" title="0">return info.Mode().IsDir()</span>
}

func PathExists(path string) bool <span class="cov8" title="1">{
        _, err := os.Stat(path)
        return err == nil
}</span>

func ValidSymlinkExists(path string) (dest string, ok bool) <span class="cov8" title="1">{
        if PathExists(path) </span><span class="cov8" title="1">{
                if link, err := os.Readlink(path); err != nil </span><span class="cov0" title="0">{
                        return link, PathExists(link)
                }</span>
        }
        <span class="cov8" title="1">return "", false</span>
}

func LookPath(file string, path string) (string, error) <span class="cov0" title="0">{
        if strings.Contains(file, "/") </span><span class="cov0" title="0">{
                err := FindExecutable(file)
                if err == nil </span><span class="cov0" title="0">{
                        return file, nil
                }</span>
                <span class="cov0" title="0">return "", &amp;exec.Error{Name: file, Err: err}</span>
        }
        <span class="cov0" title="0">for _, dir := range filepath.SplitList(path) </span><span class="cov0" title="0">{
                if dir == "" </span><span class="cov0" title="0">{
                        // Unix shell semantics: path element "" means "."
                        dir = "."
                }</span>
                <span class="cov0" title="0">path := filepath.Join(dir, file)
                if err := FindExecutable(path); err == nil </span><span class="cov0" title="0">{
                        return path, nil
                }</span>
        }
        <span class="cov0" title="0">return "", &amp;exec.Error{Name: file, Err: exec.ErrNotFound}</span>
}
func FindExecutable(file string) error <span class="cov0" title="0">{
        d, err := os.Stat(file)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if m := d.Mode(); !m.IsDir() &amp;&amp; m&amp;0111 != 0 </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return os.ErrPermission</span>
}

// TestTmpDir is intended to be used in tests and will remove itself when the
// test run is over
func TestTmpDir(t *testing.T) string <span class="cov8" title="1">{
        dir, err := ioutil.TempDir("", "bramble-test-")
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov8" title="1">if t != nil </span><span class="cov0" title="0">{
                t.Cleanup(func() </span><span class="cov0" title="0">{
                        os.RemoveAll(dir)
                }</span>)
        }
        <span class="cov8" title="1">return dir</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package hasher

import (
        "bytes"
        "encoding/base32"
        "errors"
        "fmt"
        "hash"
        "io"
        "strings"

        "github.com/minio/sha256-simd"
)

var ErrHashMismatch = errors.New("two hashes don't match")

// Hasher is used to compute path hash values. Hasher implements io.Writer and
// takes a sha256 hash of the input bytes. The output string is a lowercase
// base32 representation of the first 160 bits of the hash
type Hasher struct {
        hash hash.Hash
}

func NewHasher() *Hasher <span class="cov8" title="1">{
        return &amp;Hasher{
                hash: sha256.New(),
        }
}</span>

func (h *Hasher) Write(b []byte) (n int, err error) <span class="cov8" title="1">{
        return h.hash.Write(b)
}</span>

func (h *Hasher) String() string <span class="cov8" title="1">{
        return BytesToBase32Hash(h.hash.Sum(nil))
}</span>
func (h *Hasher) Sha256Hex() string <span class="cov8" title="1">{
        return fmt.Sprintf("%x", h.hash.Sum(nil))
}</span>

func HashString(input string) string <span class="cov0" title="0">{
        h := NewHasher()
        _, _ = h.Write([]byte(input))
        return h.String()
}</span>

// BytesToBase32Hash copies nix here
// https://nixos.org/nixos/nix-pills/nix-store-paths.html
// Finally the comments tell us to compute the base32 representation of the
// first 160 bits (truncation) of a sha256 of the above string:
func BytesToBase32Hash(b []byte) string <span class="cov8" title="1">{
        var buf bytes.Buffer
        _, _ = base32.NewEncoder(base32.StdEncoding, &amp;buf).Write(b[:20])
        return strings.ToLower(buf.String())
}</span>

func HashFile(name string, file io.ReadCloser) (fileHash, filename string, err error) <span class="cov8" title="1">{
        defer file.Close()
        hasher := NewHasher()
        if _, err = hasher.Write([]byte(name)); err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">if _, err = io.Copy(hasher, file); err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">filename = fmt.Sprintf("%s-%s", hasher.String(), name)
        return</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package logger

import (
        "fmt"
        "os"
        "strings"

        "go.uber.org/zap"
        "go.uber.org/zap/buffer"
        "go.uber.org/zap/zapcore"
)

func newLogger() *zap.SugaredLogger <span class="cov8" title="1">{
        cfg := zap.NewDevelopmentConfig()
        cfg.Encoding = "module"
        _ = zap.RegisterEncoder("module", newModuleEncoder)
        // this must be at debug level because we handle the level ourselves
        cfg.Level = zap.NewAtomicLevelAt(zap.DebugLevel)
        logger, _ := cfg.Build()
        return logger.Sugar()
}</span>

var (
        Logger = newLogger()
        Debugw = Logger.Debugw
        Debug  = Logger.Debug
        Debugf = Logger.Debugf
        Info   = Logger.Info
        Warn   = Logger.Warn
)

func newModuleEncoder(cfg zapcore.EncoderConfig) (zapcore.Encoder, error) <span class="cov8" title="1">{
        me := moduleEncoder{
                Encoder: zapcore.NewConsoleEncoder(cfg),
                level:   zapcore.ErrorLevel,
                modules: map[string]zapcore.Level{},
        }
        val := os.Getenv("BRAMBLE_LOG")
        if val == "" </span><span class="cov8" title="1">{
                return me, nil
        }</span>
        <span class="cov0" title="0">lower := strings.ToLower(val)

        stringToLevel := func(str string) (zapcore.Level, bool) </span><span class="cov0" title="0">{
                for _, lvl := range []zapcore.Level{
                        zapcore.DebugLevel,
                        zapcore.InfoLevel,
                        zapcore.WarnLevel,
                        zapcore.ErrorLevel,
                        zapcore.PanicLevel,
                        zapcore.FatalLevel} </span><span class="cov0" title="0">{
                        if str == lvl.String() </span><span class="cov0" title="0">{
                                return lvl, true
                        }</span>
                }
                <span class="cov0" title="0">if str == "off" </span><span class="cov0" title="0">{
                        return zapcore.DebugLevel - 1, true
                }</span>
                <span class="cov0" title="0">return 0, false</span>
        }

        // "error,hello=warn"
        <span class="cov0" title="0">for _, match := range strings.Split(lower, ",") </span><span class="cov0" title="0">{
                lvl, found := stringToLevel(match)
                switch </span>{
                case found:<span class="cov0" title="0"> // this is just a level
                        me.level = lvl</span>
                case !strings.Contains(match, "="):<span class="cov0" title="0"> // no equal and no level, so just a module name
                        me.modules[match] = zapcore.DebugLevel</span>
                default:<span class="cov0" title="0"> // it's the module=level syntax, ignore if malformed
                        parts := strings.Split(match, "=")
                        if len(parts) == 2 </span><span class="cov0" title="0">{
                                module, lvlString := parts[0], parts[1]
                                if lvl, found := stringToLevel(lvlString); found </span><span class="cov0" title="0">{
                                        me.modules[module] = lvl
                                }</span>
                        }
                }
        }
        <span class="cov0" title="0">return me, nil</span>
}

type moduleEncoder struct {
        zapcore.Encoder
        level   zapcore.Level
        modules map[string]zapcore.Level
}

func (me moduleEncoder) EncodeEntry(entry zapcore.Entry, fields []zapcore.Field) (*buffer.Buffer, error) <span class="cov8" title="1">{
        line, err := me.Encoder.EncodeEntry(entry, fields)
        effectiveLevel := me.level
        moduleWithFileAndLine := entry.Caller.TrimmedPath()
        if moduleWithFileAndLine != "undefined" </span><span class="cov8" title="1">{
                idx := strings.IndexRune(moduleWithFileAndLine, '/')
                if idx &gt; 0 </span><span class="cov8" title="1">{
                        moduleName := moduleWithFileAndLine[:idx]
                        if lvl, found := me.modules[moduleName]; found </span><span class="cov0" title="0">{
                                effectiveLevel = lvl
                        }</span>
                }
        }
        <span class="cov8" title="1">if entry.Level &lt; effectiveLevel </span><span class="cov8" title="1">{
                line.Reset() // return nothing
                return line, err
        }</span>
        <span class="cov0" title="0">return line, err</span>
}

func Print(a ...interface{}) <span class="cov8" title="1">{
        fmt.Fprintln(os.Stderr, a...)
}</span>
func Printfln(format string, a ...interface{}) <span class="cov8" title="1">{
        fmt.Fprintf(os.Stderr, format+"\n", a...)
}</span>
</pre>
		
		<pre class="file" id="file17" style="display: none">package progressui

// TODO: https://github.com/moby/buildkit/blob/master/LICENSE

import (
        "bytes"
        "context"
        "fmt"
        "io"
        "os"
        "sort"
        "strconv"
        "strings"
        "time"

        "github.com/containerd/console"
        "github.com/jaguilar/vt100"
        "github.com/morikuni/aec"
        "github.com/tonistiigi/units"
        "golang.org/x/time/rate"
)

func DisplaySolveStatus(ctx context.Context, phase string, c console.Console, w io.Writer, ch chan *SolveStatus) error <span class="cov0" title="0">{
        modeConsole := c != nil

        disp := &amp;display{c: c, phase: phase}
        printer := &amp;textMux{w: w}

        if disp.phase == "" </span><span class="cov0" title="0">{
                disp.phase = "Building"
        }</span>

        <span class="cov0" title="0">t := newTrace(w, modeConsole)

        tickerTimeout := 150 * time.Millisecond
        displayTimeout := 100 * time.Millisecond

        if v := os.Getenv("TTY_DISPLAY_RATE"); v != "" </span><span class="cov0" title="0">{
                if r, err := strconv.ParseInt(v, 10, 64); err == nil </span><span class="cov0" title="0">{
                        tickerTimeout = time.Duration(r) * time.Millisecond
                        displayTimeout = time.Duration(r) * time.Millisecond
                }</span>
        }

        <span class="cov0" title="0">var done bool
        ticker := time.NewTicker(tickerTimeout)
        defer ticker.Stop()

        displayLimiter := rate.NewLimiter(rate.Every(displayTimeout), 1)

        var height int
        width, _ := disp.getSize()
        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return ctx.Err()</span>
                case &lt;-ticker.C:<span class="cov0" title="0"></span>
                case ss, ok := &lt;-ch:<span class="cov0" title="0">
                        if ok </span><span class="cov0" title="0">{
                                t.update(ss, width)
                        }</span> else<span class="cov0" title="0"> {
                                done = true
                        }</span>
                }

                <span class="cov0" title="0">if modeConsole </span><span class="cov0" title="0">{
                        width, height = disp.getSize()
                        if done </span><span class="cov0" title="0">{
                                disp.print(t.displayInfo(), width, height, true)
                                t.printErrorLogs(c)
                                return nil
                        }</span> else<span class="cov0" title="0"> if displayLimiter.Allow() </span><span class="cov0" title="0">{
                                ticker.Stop()
                                ticker = time.NewTicker(tickerTimeout)
                                disp.print(t.displayInfo(), width, height, false)
                        }</span>
                } else<span class="cov0" title="0"> if done || displayLimiter.Allow() </span><span class="cov0" title="0">{
                        printer.print(t)
                        if done </span><span class="cov0" title="0">{
                                t.printErrorLogs(w)
                                return nil
                        }</span>
                        <span class="cov0" title="0">ticker.Stop()
                        ticker = time.NewTicker(tickerTimeout)</span>
                }
        }
}

const termHeight = 6
const termPad = 10

type displayInfo struct {
        startTime      time.Time
        jobs           []*job
        countTotal     int
        countCompleted int
}

type job struct {
        startTime     *time.Time
        completedTime *time.Time
        name          string
        status        string
        hasError      bool
        isCanceled    bool
        vertex        *vertex
        showTerm      bool
}

type trace struct {
        w             io.Writer
        localTimeDiff time.Duration
        vertexes      []*vertex
        byDigest      map[Digest]*vertex
        nextIndex     int
        updates       map[Digest]struct{}
        modeConsole   bool
}

type vertex struct {
        *Vertex
        statuses []*status
        byID     map[string]*status
        indent   string
        index    int

        logs          [][]byte
        logsPartial   bool
        logsOffset    int
        prev          *Vertex
        events        []string
        lastBlockTime *time.Time
        count         int
        statusUpdates map[string]struct{}

        jobs      []*job
        jobCached bool

        term      *vt100.VT100
        termBytes int
        termCount int
}

func (v *vertex) update(c int) <span class="cov0" title="0">{
        if v.count == 0 </span><span class="cov0" title="0">{
                now := time.Now()
                v.lastBlockTime = &amp;now
        }</span>
        <span class="cov0" title="0">v.count += c</span>
}

type status struct {
        *VertexStatus
}

func newTrace(w io.Writer, modeConsole bool) *trace <span class="cov0" title="0">{
        return &amp;trace{
                byDigest:    make(map[Digest]*vertex),
                updates:     make(map[Digest]struct{}),
                w:           w,
                modeConsole: modeConsole,
        }
}</span>

func (t *trace) triggerVertexEvent(v *Vertex) <span class="cov0" title="0">{
        if v.Started == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">var old Vertex
        vtx := t.byDigest[v.Digest]
        if v := vtx.prev; v != nil </span><span class="cov0" title="0">{
                old = *v
        }</span>

        <span class="cov0" title="0">changed := false
        if v.Digest != old.Digest </span><span class="cov0" title="0">{
                changed = true
        }</span>
        <span class="cov0" title="0">if v.Name != old.Name </span><span class="cov0" title="0">{
                changed = true
        }</span>
        <span class="cov0" title="0">if v.Started != old.Started </span><span class="cov0" title="0">{
                if v.Started != nil &amp;&amp; old.Started == nil || !v.Started.Equal(*old.Started) </span><span class="cov0" title="0">{
                        changed = true
                }</span>
        }
        <span class="cov0" title="0">if v.Completed != old.Completed &amp;&amp; v.Completed != nil </span><span class="cov0" title="0">{
                changed = true
        }</span>
        <span class="cov0" title="0">if v.Cached != old.Cached </span><span class="cov0" title="0">{
                changed = true
        }</span>
        <span class="cov0" title="0">if v.Error != old.Error </span><span class="cov0" title="0">{
                changed = true
        }</span>

        <span class="cov0" title="0">if changed </span><span class="cov0" title="0">{
                vtx.update(1)
                t.updates[v.Digest] = struct{}{}
        }</span>

        <span class="cov0" title="0">t.byDigest[v.Digest].prev = v</span>
}

func (t *trace) update(s *SolveStatus, termWidth int) <span class="cov0" title="0">{
        for _, v := range s.Vertexes </span><span class="cov0" title="0">{
                prev, ok := t.byDigest[v.Digest]
                if !ok </span><span class="cov0" title="0">{
                        t.nextIndex++
                        t.byDigest[v.Digest] = &amp;vertex{
                                byID:          make(map[string]*status),
                                statusUpdates: make(map[string]struct{}),
                                index:         t.nextIndex,
                        }
                        if t.modeConsole </span><span class="cov0" title="0">{
                                t.byDigest[v.Digest].term = vt100.NewVT100(termHeight, termWidth-termPad)
                        }</span>
                }
                <span class="cov0" title="0">t.triggerVertexEvent(v)
                if v.Started != nil &amp;&amp; (prev == nil || prev.Started == nil) </span><span class="cov0" title="0">{
                        if t.localTimeDiff == 0 </span><span class="cov0" title="0">{
                                t.localTimeDiff = time.Since(*v.Started)
                        }</span>
                        <span class="cov0" title="0">t.vertexes = append(t.vertexes, t.byDigest[v.Digest])</span>
                }
                // allow a duplicate initial vertex that shouldn't reset state
                <span class="cov0" title="0">if !(prev != nil &amp;&amp; prev.Started != nil &amp;&amp; v.Started == nil) </span><span class="cov0" title="0">{
                        t.byDigest[v.Digest].Vertex = v
                }</span>
                <span class="cov0" title="0">t.byDigest[v.Digest].jobCached = false</span>
        }
        <span class="cov0" title="0">for _, s := range s.Statuses </span><span class="cov0" title="0">{
                v, ok := t.byDigest[s.Vertex]
                if !ok </span><span class="cov0" title="0">{
                        continue</span> // shouldn't happen
                }
                <span class="cov0" title="0">v.jobCached = false
                prev, ok := v.byID[s.ID]
                if !ok </span><span class="cov0" title="0">{
                        v.byID[s.ID] = &amp;status{VertexStatus: s}
                }</span>
                <span class="cov0" title="0">if s.Started != nil &amp;&amp; (prev == nil || prev.Started == nil) </span><span class="cov0" title="0">{
                        v.statuses = append(v.statuses, v.byID[s.ID])
                }</span>
                <span class="cov0" title="0">v.byID[s.ID].VertexStatus = s
                v.statusUpdates[s.ID] = struct{}{}
                t.updates[v.Digest] = struct{}{}
                v.update(1)</span>
        }
        <span class="cov0" title="0">for _, l := range s.Logs </span><span class="cov0" title="0">{
                v, ok := t.byDigest[l.Vertex]
                if !ok </span><span class="cov0" title="0">{
                        continue</span> // shouldn't happen
                }
                <span class="cov0" title="0">v.jobCached = false
                if v.term != nil </span><span class="cov0" title="0">{
                        if v.term.Width != termWidth </span><span class="cov0" title="0">{
                                v.term.Resize(termHeight, termWidth-termPad)
                        }</span>
                        <span class="cov0" title="0">v.termBytes += len(l.Data)
                        _, _ = v.term.Write(l.Data)</span> // error unhandled on purpose. don't trust vt100
                }
                <span class="cov0" title="0">i := 0
                complete := split(l.Data, byte('\n'), func(dt []byte) </span><span class="cov0" title="0">{
                        if v.logsPartial &amp;&amp; len(v.logs) != 0 &amp;&amp; i == 0 </span><span class="cov0" title="0">{
                                v.logs[len(v.logs)-1] = append(v.logs[len(v.logs)-1], dt...)
                        }</span> else<span class="cov0" title="0"> {
                                ts := time.Duration(0)
                                if v.Started != nil </span><span class="cov0" title="0">{
                                        ts = l.Timestamp.Sub(*v.Started)
                                }</span>
                                <span class="cov0" title="0">prec := 1
                                sec := ts.Seconds()
                                if sec &lt; 10 </span><span class="cov0" title="0">{
                                        prec = 3
                                }</span> else<span class="cov0" title="0"> if sec &lt; 100 </span><span class="cov0" title="0">{
                                        prec = 2
                                }</span>
                                <span class="cov0" title="0">v.logs = append(v.logs, []byte(fmt.Sprintf("#%d %s %s", v.index, fmt.Sprintf("%.[2]*[1]f", sec, prec), dt)))</span>
                        }
                        <span class="cov0" title="0">i++</span>
                })
                <span class="cov0" title="0">v.logsPartial = !complete
                t.updates[v.Digest] = struct{}{}
                v.update(1)</span>
        }
}

func (t *trace) printErrorLogs(f io.Writer) <span class="cov0" title="0">{
        for _, v := range t.vertexes </span><span class="cov0" title="0">{
                if v.Error != "" &amp;&amp; !strings.HasSuffix(v.Error, context.Canceled.Error()) </span><span class="cov0" title="0">{
                        fmt.Fprintln(f, "------")
                        fmt.Fprintf(f, " &gt; %s:\n", v.Name)
                        for _, l := range v.logs </span><span class="cov0" title="0">{
                                _, _ = f.Write(l)
                                fmt.Fprintln(f)
                        }</span>
                        <span class="cov0" title="0">fmt.Fprintln(f, "------")</span>
                }
        }
}

func (t *trace) displayInfo() (d displayInfo) <span class="cov0" title="0">{
        d.startTime = time.Now()
        if t.localTimeDiff != 0 </span><span class="cov0" title="0">{
                d.startTime = (*t.vertexes[0].Started).Add(t.localTimeDiff)
        }</span>
        <span class="cov0" title="0">d.countTotal = len(t.byDigest)
        for _, v := range t.byDigest </span><span class="cov0" title="0">{
                if v.Completed != nil </span><span class="cov0" title="0">{
                        d.countCompleted++
                }</span>
        }

        <span class="cov0" title="0">for _, v := range t.vertexes </span><span class="cov0" title="0">{
                if v.jobCached </span><span class="cov0" title="0">{
                        d.jobs = append(d.jobs, v.jobs...)
                        continue</span>
                }
                <span class="cov0" title="0">var jobs []*job
                j := &amp;job{
                        startTime:     addTime(v.Started, t.localTimeDiff),
                        completedTime: addTime(v.Completed, t.localTimeDiff),
                        name:          strings.Replace(v.Name, "\t", " ", -1),
                        vertex:        v,
                }
                if v.Error != "" </span><span class="cov0" title="0">{
                        if strings.HasSuffix(v.Error, context.Canceled.Error()) </span><span class="cov0" title="0">{
                                j.isCanceled = true
                                j.name = "CANCELED " + j.name
                        }</span> else<span class="cov0" title="0"> {
                                j.hasError = true
                                j.name = "ERROR " + j.name
                        }</span>
                }
                <span class="cov0" title="0">if v.Cached </span><span class="cov0" title="0">{
                        j.name = "CACHED " + j.name
                }</span>
                <span class="cov0" title="0">j.name = v.indent + j.name
                jobs = append(jobs, j)
                for _, s := range v.statuses </span><span class="cov0" title="0">{
                        j := &amp;job{
                                startTime:     addTime(s.Started, t.localTimeDiff),
                                completedTime: addTime(s.Completed, t.localTimeDiff),
                                name:          v.indent + "=&gt; " + s.ID,
                        }
                        if s.Total != 0 </span><span class="cov0" title="0">{
                                j.status = fmt.Sprintf("%.2f / %.2f", units.Bytes(s.Current), units.Bytes(s.Total))
                        }</span> else<span class="cov0" title="0"> if s.Current != 0 </span><span class="cov0" title="0">{
                                j.status = fmt.Sprintf("%.2f", units.Bytes(s.Current))
                        }</span>
                        <span class="cov0" title="0">jobs = append(jobs, j)</span>
                }
                <span class="cov0" title="0">d.jobs = append(d.jobs, jobs...)
                v.jobs = jobs
                v.jobCached = true</span>
        }

        <span class="cov0" title="0">return d</span>
}

func split(dt []byte, sep byte, fn func([]byte)) bool <span class="cov0" title="0">{
        if len(dt) == 0 </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">for </span><span class="cov0" title="0">{
                if len(dt) == 0 </span><span class="cov0" title="0">{
                        return true
                }</span>
                <span class="cov0" title="0">idx := bytes.IndexByte(dt, sep)
                if idx == -1 </span><span class="cov0" title="0">{
                        fn(dt)
                        return false
                }</span>
                <span class="cov0" title="0">fn(dt[:idx])
                dt = dt[idx+1:]</span>
        }
}

func addTime(tm *time.Time, d time.Duration) *time.Time <span class="cov0" title="0">{
        if tm == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">t := (*tm).Add(d)
        return &amp;t</span>
}

type display struct {
        c         console.Console
        phase     string
        lineCount int
        repeated  bool
}

func (disp *display) getSize() (int, int) <span class="cov0" title="0">{
        width := 80
        height := 10
        if disp.c != nil </span><span class="cov0" title="0">{
                size, err := disp.c.Size()
                if err == nil &amp;&amp; size.Width &gt; 0 &amp;&amp; size.Height &gt; 0 </span><span class="cov0" title="0">{
                        width = int(size.Width)
                        height = int(size.Height)
                }</span>
        }
        <span class="cov0" title="0">return width, height</span>
}

func setupTerminals(jobs []*job, height int, all bool) []*job <span class="cov0" title="0">{
        var candidates []*job
        numInUse := 0
        for _, j := range jobs </span><span class="cov0" title="0">{
                if j.vertex != nil &amp;&amp; j.vertex.termBytes &gt; 0 &amp;&amp; j.completedTime == nil </span><span class="cov0" title="0">{
                        candidates = append(candidates, j)
                }</span>
                <span class="cov0" title="0">if j.completedTime == nil </span><span class="cov0" title="0">{
                        numInUse++
                }</span>
        }
        <span class="cov0" title="0">sort.Slice(candidates, func(i, j int) bool </span><span class="cov0" title="0">{
                idxI := candidates[i].vertex.termBytes + candidates[i].vertex.termCount*50
                idxJ := candidates[j].vertex.termBytes + candidates[j].vertex.termCount*50
                return idxI &gt; idxJ
        }</span>)

        <span class="cov0" title="0">numFree := height - 2 - numInUse
        numToHide := 0
        termLimit := termHeight + 3

        for i := 0; numFree &gt; termLimit &amp;&amp; i &lt; len(candidates); i++ </span><span class="cov0" title="0">{
                candidates[i].showTerm = true
                numToHide += candidates[i].vertex.term.UsedHeight()
                numFree -= termLimit
        }</span>

        <span class="cov0" title="0">if !all </span><span class="cov0" title="0">{
                jobs = wrapHeight(jobs, height-2-numToHide)
        }</span>

        <span class="cov0" title="0">return jobs</span>
}

func (disp *display) print(d displayInfo, width, height int, all bool) <span class="cov0" title="0">{
        // this output is inspired by Buck
        d.jobs = setupTerminals(d.jobs, height, all)
        b := aec.EmptyBuilder
        for i := 0; i &lt;= disp.lineCount; i++ </span><span class="cov0" title="0">{
                b = b.Up(1)
        }</span>
        <span class="cov0" title="0">if !disp.repeated </span><span class="cov0" title="0">{
                b = b.Down(1)
        }</span>
        <span class="cov0" title="0">disp.repeated = true
        fmt.Fprint(disp.c, b.Column(0).ANSI)

        statusStr := ""
        if d.countCompleted &gt; 0 &amp;&amp; d.countCompleted == d.countTotal &amp;&amp; all </span><span class="cov0" title="0">{
                statusStr = "FINISHED"
        }</span>

        <span class="cov0" title="0">fmt.Fprint(disp.c, aec.Hide)
        defer fmt.Fprint(disp.c, aec.Show)

        out := fmt.Sprintf("[+] %s %.1fs (%d/%d) %s", disp.phase, time.Since(d.startTime).Seconds(), d.countCompleted, d.countTotal, statusStr)
        out = align(out, "", width)
        fmt.Fprintln(disp.c, out)
        lineCount := 0
        for _, j := range d.jobs </span><span class="cov0" title="0">{
                endTime := time.Now()
                if j.completedTime != nil </span><span class="cov0" title="0">{
                        endTime = *j.completedTime
                }</span>
                <span class="cov0" title="0">if j.startTime == nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">dt := endTime.Sub(*j.startTime).Seconds()
                if dt &lt; 0.05 </span><span class="cov0" title="0">{
                        dt = 0
                }</span>
                <span class="cov0" title="0">pfx := " =&gt; "
                timer := fmt.Sprintf(" %3.1fs\n", dt)
                status := j.status
                showStatus := false

                left := width - len(pfx) - len(timer) - 1
                if status != "" </span><span class="cov0" title="0">{
                        if left+len(status) &gt; 20 </span><span class="cov0" title="0">{
                                showStatus = true
                                left -= len(status) + 1
                        }</span>
                }
                <span class="cov0" title="0">if left &lt; 12 </span><span class="cov0" title="0">{ // too small screen to show progress
                        continue</span>
                }
                <span class="cov0" title="0">name := j.name
                if len(name) &gt; left </span><span class="cov0" title="0">{
                        name = name[:left]
                }</span>

                <span class="cov0" title="0">out := pfx + name
                if showStatus </span><span class="cov0" title="0">{
                        out += " " + status
                }</span>

                <span class="cov0" title="0">out = align(out, timer, width)
                if j.completedTime != nil </span><span class="cov0" title="0">{
                        color := aec.BlueF
                        if j.isCanceled </span><span class="cov0" title="0">{
                                color = aec.YellowF
                        }</span> else<span class="cov0" title="0"> if j.hasError </span><span class="cov0" title="0">{
                                color = aec.RedF
                        }</span>
                        <span class="cov0" title="0">out = aec.Apply(out, color)</span>
                }
                <span class="cov0" title="0">fmt.Fprint(disp.c, out)
                lineCount++
                if j.showTerm </span><span class="cov0" title="0">{
                        term := j.vertex.term
                        term.Resize(termHeight, width-termPad)
                        for _, l := range term.Content </span><span class="cov0" title="0">{
                                if !isEmpty(l) </span><span class="cov0" title="0">{
                                        out := aec.Apply(fmt.Sprintf(" =&gt; =&gt; # %s\n", string(l)), aec.Faint)
                                        fmt.Fprint(disp.c, out)
                                        lineCount++
                                }</span>
                        }
                        <span class="cov0" title="0">j.vertex.termCount++
                        j.showTerm = false</span>
                }
        }
        // override previous content
        <span class="cov0" title="0">if diff := disp.lineCount - lineCount; diff &gt; 0 </span><span class="cov0" title="0">{
                for i := 0; i &lt; diff; i++ </span><span class="cov0" title="0">{
                        fmt.Fprintln(disp.c, strings.Repeat(" ", width))
                }</span>
                <span class="cov0" title="0">fmt.Fprint(disp.c, aec.EmptyBuilder.Up(uint(diff)).Column(0).ANSI)</span>
        }
        <span class="cov0" title="0">disp.lineCount = lineCount</span>
}

func isEmpty(l []rune) bool <span class="cov0" title="0">{
        for _, r := range l </span><span class="cov0" title="0">{
                if r != ' ' </span><span class="cov0" title="0">{
                        return false
                }</span>
        }
        <span class="cov0" title="0">return true</span>
}

func align(l, r string, w int) string <span class="cov0" title="0">{
        return fmt.Sprintf("%-[2]*[1]s %[3]s", l, w-len(r)-1, r)
}</span>

func wrapHeight(j []*job, limit int) []*job <span class="cov0" title="0">{
        if limit &lt; 0 </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">var wrapped []*job
        wrapped = append(wrapped, j...)
        if len(j) &gt; limit </span><span class="cov0" title="0">{
                wrapped = wrapped[len(j)-limit:]

                // wrap things around if incomplete jobs were cut
                var invisible []*job
                for _, j := range j[:len(j)-limit] </span><span class="cov0" title="0">{
                        if j.completedTime == nil </span><span class="cov0" title="0">{
                                invisible = append(invisible, j)
                        }</span>
                }

                <span class="cov0" title="0">if l := len(invisible); l &gt; 0 </span><span class="cov0" title="0">{
                        rewrapped := make([]*job, 0, len(wrapped))
                        for _, j := range wrapped </span><span class="cov0" title="0">{
                                if j.completedTime == nil || l &lt;= 0 </span><span class="cov0" title="0">{
                                        rewrapped = append(rewrapped, j)
                                }</span>
                                <span class="cov0" title="0">l--</span>
                        }
                        <span class="cov0" title="0">freespace := len(wrapped) - len(rewrapped)
                        wrapped = append(invisible[len(invisible)-freespace:], rewrapped...)</span>
                }
        }
        <span class="cov0" title="0">return wrapped</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package progressui

import (
        "context"
        "fmt"
        "io"
        "os"
        "sort"
        "strings"
        "time"

        "github.com/tonistiigi/units"
)

const antiFlicker = 5 * time.Second
const maxDelay = 10 * time.Second
const minTimeDelta = 5 * time.Second
const minProgressDelta = 0.05 // %

type lastStatus struct {
        Current   int64
        Timestamp time.Time
}

type textMux struct {
        w        io.Writer
        current  Digest
        last     map[string]lastStatus
        notFirst bool
}

func (p *textMux) printVtx(t *trace, dgst Digest) <span class="cov0" title="0">{
        if p.last == nil </span><span class="cov0" title="0">{
                p.last = make(map[string]lastStatus)
        }</span>

        <span class="cov0" title="0">v, ok := t.byDigest[dgst]
        if !ok </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">if dgst != p.current </span><span class="cov0" title="0">{
                if p.current != "" </span><span class="cov0" title="0">{
                        old := t.byDigest[p.current]
                        if old.logsPartial </span><span class="cov0" title="0">{
                                fmt.Fprintln(p.w, "")
                        }</span>
                        <span class="cov0" title="0">old.logsOffset = 0
                        old.count = 0
                        fmt.Fprintf(p.w, "#%d ...\n", old.index)</span>
                }

                <span class="cov0" title="0">if p.notFirst </span><span class="cov0" title="0">{
                        fmt.Fprintln(p.w, "")
                }</span> else<span class="cov0" title="0"> {
                        p.notFirst = true
                }</span>

                <span class="cov0" title="0">if os.Getenv("PROGRESS_NO_TRUNC") == "0" </span><span class="cov0" title="0">{
                        fmt.Fprintf(p.w, "#%d %s\n", v.index, limitString(v.Name, 72))
                }</span> else<span class="cov0" title="0"> {
                        fmt.Fprintf(p.w, "#%d %s\n", v.index, v.Name)
                        fmt.Fprintf(p.w, "#%d %s\n", v.index, v.Digest)
                }</span>
        }

        <span class="cov0" title="0">if len(v.events) != 0 </span><span class="cov0" title="0">{
                v.logsOffset = 0
        }</span>
        <span class="cov0" title="0">for _, ev := range v.events </span><span class="cov0" title="0">{
                fmt.Fprintf(p.w, "#%d %s\n", v.index, ev)
        }</span>
        <span class="cov0" title="0">v.events = v.events[:0]

        for _, s := range v.statuses </span><span class="cov0" title="0">{
                if _, ok := v.statusUpdates[s.ID]; ok </span><span class="cov0" title="0">{
                        doPrint := true

                        if last, ok := p.last[s.ID]; ok &amp;&amp; s.Completed == nil </span><span class="cov0" title="0">{
                                var progressDelta float64
                                if s.Total &gt; 0 </span><span class="cov0" title="0">{
                                        progressDelta = float64(s.Current-last.Current) / float64(s.Total)
                                }</span>
                                <span class="cov0" title="0">timeDelta := s.Timestamp.Sub(last.Timestamp)
                                if progressDelta &lt; minProgressDelta &amp;&amp; timeDelta &lt; minTimeDelta </span><span class="cov0" title="0">{
                                        doPrint = false
                                }</span>
                        }

                        <span class="cov0" title="0">if !doPrint </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov0" title="0">p.last[s.ID] = lastStatus{
                                Timestamp: s.Timestamp,
                                Current:   s.Current,
                        }

                        var bytes string
                        if s.Total != 0 </span><span class="cov0" title="0">{
                                bytes = fmt.Sprintf(" %.2f / %.2f", units.Bytes(s.Current), units.Bytes(s.Total))
                        }</span> else<span class="cov0" title="0"> if s.Current != 0 </span><span class="cov0" title="0">{
                                bytes = fmt.Sprintf(" %.2f", units.Bytes(s.Current))
                        }</span>
                        <span class="cov0" title="0">var tm string
                        endTime := s.Timestamp
                        if s.Completed != nil </span><span class="cov0" title="0">{
                                endTime = *s.Completed
                        }</span>
                        <span class="cov0" title="0">if s.Started != nil </span><span class="cov0" title="0">{
                                diff := endTime.Sub(*s.Started).Seconds()
                                if diff &gt; 0.01 </span><span class="cov0" title="0">{
                                        tm = fmt.Sprintf(" %.1fs", diff)
                                }</span>
                        }
                        <span class="cov0" title="0">if s.Completed != nil </span><span class="cov0" title="0">{
                                tm += " done"
                        }</span>
                        <span class="cov0" title="0">fmt.Fprintf(p.w, "#%d %s%s%s\n", v.index, s.ID, bytes, tm)</span>
                }
        }
        <span class="cov0" title="0">v.statusUpdates = map[string]struct{}{}

        for i, l := range v.logs </span><span class="cov0" title="0">{
                if i == 0 </span><span class="cov0" title="0">{
                        l = l[v.logsOffset:]
                }</span>
                <span class="cov0" title="0">fmt.Fprintf(p.w, "%s", []byte(l))
                if i != len(v.logs)-1 || !v.logsPartial </span><span class="cov0" title="0">{
                        fmt.Fprintln(p.w, "")
                }</span>
        }

        <span class="cov0" title="0">if len(v.logs) &gt; 0 </span><span class="cov0" title="0">{
                if v.logsPartial </span><span class="cov0" title="0">{
                        v.logs = v.logs[len(v.logs)-1:]
                        v.logsOffset = len(v.logs[0])
                }</span> else<span class="cov0" title="0"> {
                        v.logs = nil
                        v.logsOffset = 0
                }</span>
        }

        <span class="cov0" title="0">p.current = dgst
        if v.Completed != nil </span><span class="cov0" title="0">{
                p.current = ""
                v.count = 0

                if v.Error != "" </span><span class="cov0" title="0">{
                        if v.logsPartial </span><span class="cov0" title="0">{
                                fmt.Fprintln(p.w, "")
                        }</span>
                        <span class="cov0" title="0">if strings.HasSuffix(v.Error, context.Canceled.Error()) </span><span class="cov0" title="0">{
                                fmt.Fprintf(p.w, "#%d CANCELED\n", v.index)
                        }</span> else<span class="cov0" title="0"> {
                                fmt.Fprintf(p.w, "#%d ERROR: %s\n", v.index, v.Error)
                        }</span>
                } else<span class="cov0" title="0"> if v.Cached </span><span class="cov0" title="0">{
                        fmt.Fprintf(p.w, "#%d CACHED\n", v.index)
                }</span> else<span class="cov0" title="0"> {
                        tm := ""
                        if v.Started != nil </span><span class="cov0" title="0">{
                                tm = fmt.Sprintf(" %.1fs", v.Completed.Sub(*v.Started).Seconds())
                        }</span>
                        <span class="cov0" title="0">fmt.Fprintf(p.w, "#%d DONE%s\n", v.index, tm)</span>
                }
        }
        <span class="cov0" title="0">delete(t.updates, dgst)</span>
}

func sortCompleted(t *trace, m map[Digest]struct{}) []Digest <span class="cov0" title="0">{
        out := make([]Digest, 0, len(m))
        for k := range m </span><span class="cov0" title="0">{
                out = append(out, k)
        }</span>
        <span class="cov0" title="0">sort.Slice(out, func(i, j int) bool </span><span class="cov0" title="0">{
                return t.byDigest[out[i]].Completed.Before(*t.byDigest[out[j]].Completed)
        }</span>)
        <span class="cov0" title="0">return out</span>
}

func (p *textMux) print(t *trace) <span class="cov0" title="0">{
        completed := map[Digest]struct{}{}
        rest := map[Digest]struct{}{}

        for dgst := range t.updates </span><span class="cov0" title="0">{
                v, ok := t.byDigest[dgst]
                if !ok </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">if v.Vertex.Completed != nil </span><span class="cov0" title="0">{
                        completed[dgst] = struct{}{}
                }</span> else<span class="cov0" title="0"> {
                        rest[dgst] = struct{}{}
                }</span>
        }

        <span class="cov0" title="0">current := p.current

        // items that have completed need to be printed first
        if _, ok := completed[current]; ok </span><span class="cov0" title="0">{
                p.printVtx(t, current)
        }</span>

        <span class="cov0" title="0">for _, dgst := range sortCompleted(t, completed) </span><span class="cov0" title="0">{
                if dgst != current </span><span class="cov0" title="0">{
                        p.printVtx(t, dgst)
                }</span>
        }

        <span class="cov0" title="0">if len(rest) == 0 </span><span class="cov0" title="0">{
                if current != "" </span><span class="cov0" title="0">{
                        if v := t.byDigest[current]; v.Started != nil &amp;&amp; v.Completed == nil </span><span class="cov0" title="0">{
                                return
                        }</span>
                }
                // make any open vertex active
                <span class="cov0" title="0">for dgst, v := range t.byDigest </span><span class="cov0" title="0">{
                        if v.Started != nil &amp;&amp; v.Completed == nil </span><span class="cov0" title="0">{
                                p.printVtx(t, dgst)
                                return
                        }</span>
                }
                <span class="cov0" title="0">return</span>
        }

        // now print the active one
        <span class="cov0" title="0">if _, ok := rest[current]; ok </span><span class="cov0" title="0">{
                p.printVtx(t, current)
        }</span>

        <span class="cov0" title="0">stats := map[Digest]*vtxStat{}
        now := time.Now()
        sum := 0.0
        var max Digest
        if current != "" </span><span class="cov0" title="0">{
                rest[current] = struct{}{}
        }</span>
        <span class="cov0" title="0">for dgst := range rest </span><span class="cov0" title="0">{
                v, ok := t.byDigest[dgst]
                if !ok </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">tm := now.Sub(*v.lastBlockTime)
                speed := float64(v.count) / tm.Seconds()
                overLimit := tm &gt; maxDelay &amp;&amp; dgst != current
                stats[dgst] = &amp;vtxStat{blockTime: tm, speed: speed, overLimit: overLimit}
                sum += speed
                if overLimit || max == "" || stats[max].speed &lt; speed </span><span class="cov0" title="0">{
                        max = dgst
                }</span>
        }
        <span class="cov0" title="0">for dgst := range stats </span><span class="cov0" title="0">{
                stats[dgst].share = stats[dgst].speed / sum
        }</span>

        <span class="cov0" title="0">if _, ok := completed[current]; ok || current == "" </span><span class="cov0" title="0">{
                p.printVtx(t, max)
                return
        }</span>

        // show items that were hidden
        <span class="cov0" title="0">for dgst := range rest </span><span class="cov0" title="0">{
                if stats[dgst].overLimit </span><span class="cov0" title="0">{
                        p.printVtx(t, dgst)
                        return
                }</span>
        }

        // fair split between vertexes
        <span class="cov0" title="0">if 1.0/(1.0-stats[current].share)*antiFlicker.Seconds() &lt; stats[current].blockTime.Seconds() </span><span class="cov0" title="0">{
                p.printVtx(t, max)
                return
        }</span>
}

type vtxStat struct {
        blockTime time.Duration
        speed     float64
        share     float64
        overLimit bool
}

func limitString(s string, l int) string <span class="cov0" title="0">{
        if len(s) &gt; l </span><span class="cov0" title="0">{
                return s[:l] + "..."
        }</span>
        <span class="cov0" title="0">return s</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package reptar

import (
        "archive/tar"
        "compress/gzip"
        "fmt"
        "io"
        "os"
        "path/filepath"
        "strings"
        "time"
)

var zeroTime time.Time

// References:
// http://h2.jaguarpaw.co.uk/posts/reproducible-tar/
// https://reproducible-builds.org/docs/archives/

// Reptar creates a tar of a location. Reptar stands for reproducible tar and
// is intended to replicate the following gnu tar command:
//
//    tar - \
//    --sort=name \
//    --mtime="1970-01-01 00:00:00Z" \
//    --owner=0 --group=0 --numeric-owner \
//    --pax-option=exthdr.name=%d/PaxHeaders/%f,delete=atime,delete=ctime \
//    -cf
//
// This command is currently not complete and only works on very basic test
// cases. GNU Tar also adds padding to outputted files
func Reptar(location string, out io.Writer) (err error) <span class="cov8" title="1">{
        // TODO: add our own null padding to match GNU Tar
        // TODO: test with hardlinks
        // TODO: confirm name sorting is identical in all cases
        // TODO: disallow absolute paths

        tw := tar.NewWriter(out)
        if err = filepath.Walk(location, func(path string, fi os.FileInfo, err error) error </span><span class="cov8" title="1">{
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">var linkTarget string
                if isSymlink(fi) </span><span class="cov8" title="1">{
                        var err error
                        linkTarget, err = os.Readlink(path)
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("%s: readlink: %w", fi.Name(), err)
                        }</span>
                        // TODO: convert from absolute to relative
                }
                // GNU Tar adds a slash to the end of directories, but Go removes them
                <span class="cov8" title="1">if fi.IsDir() </span><span class="cov8" title="1">{
                        path += "/"
                }</span>
                <span class="cov8" title="1">hdr, err := tar.FileInfoHeader(fi, filepath.ToSlash(linkTarget))
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // Setting an explicit unix epoch using time.Date(1970, time.January..)
                // resulted in zeros in the timestamp and not null, so we explicitly
                // use a null time
                <span class="cov8" title="1">hdr.ModTime = zeroTime
                hdr.AccessTime = zeroTime
                hdr.ChangeTime = zeroTime

                // It seems that both seeing these to 0 and using empty strings for
                // Gname and Uname is required
                hdr.Uid = 0
                hdr.Gid = 0
                hdr.Gname = ""
                hdr.Uname = ""

                // pax format
                hdr.Format = tar.FormatPAX

                hdr.Name = strings.TrimPrefix(path, location)

                if err = tw.WriteHeader(hdr); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("%s: writing header: %w", hdr.Name, err)
                }</span>

                <span class="cov8" title="1">if fi.IsDir() </span><span class="cov8" title="1">{
                        return nil // directories have no contents
                }</span>
                <span class="cov8" title="1">if hdr.Typeflag == tar.TypeReg </span><span class="cov8" title="1">{
                        var file io.ReadCloser
                        file, err = os.Open(path)
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("%s: opening: %w", path, err)
                        }</span>
                        <span class="cov8" title="1">_, err := io.Copy(tw, file)
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("%s: copying contents: %v", fi.Name(), err)
                        }</span>
                        <span class="cov8" title="1">_ = file.Close()</span>
                }
                <span class="cov8" title="1">return nil</span>
        }); err != nil <span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">return tw.Close()</span>
}

// GzipReptar just wraps reptar in gzip. This seems like a good place for a
// godzilla pun but I couldn't think of anything. Contributions welcome
func GzipReptar(location string, out io.Writer) (err error) <span class="cov0" title="0">{
        w := gzip.NewWriter(out)
        defer w.Close()
        return Reptar(location, w)
}</span>

func isSymlink(fi os.FileInfo) bool <span class="cov8" title="1">{
        return fi.Mode()&amp;os.ModeSymlink != 0
}</span>
</pre>
		
		<pre class="file" id="file20" style="display: none">package sandbox

import (
        "fmt"
        "os"
        "path/filepath"
        "strings"
        "syscall"

        "github.com/maxmcd/bramble/pkg/logger"
        "github.com/pkg/errors"
)

type chroot struct {
        initialized bool
        chrooted    bool
        location    string
        mounts      []string
}

func parseMount(mnt string) (src string, ro bool, valid bool) <span class="cov0" title="0">{
        parts := strings.Split(mnt, ":")
        switch len(parts) </span>{
        case 1:<span class="cov0" title="0">
                return parts[0], false, true</span>
        case 2:<span class="cov0" title="0">
                return parts[0], parts[1] == "ro", true</span>
        }
        <span class="cov0" title="0">valid = false
        return</span>
}

func newChroot(location string, mounts []string) *chroot <span class="cov0" title="0">{
        return &amp;chroot{
                location: location,
                mounts:   mounts,
        }
}</span>

func makedev(major int, minor int) int <span class="cov0" title="0">{
        return (minor &amp; 0xff) | (major&amp;0xfff)&lt;&lt;8
}</span>

func (chr *chroot) Init() (err error) <span class="cov0" title="0">{
        if chr.initialized </span><span class="cov0" title="0">{
                return errors.New("chroot env already initialized")
        }</span>
        <span class="cov0" title="0">chr.initialized = true

        // reset file mode creation mask to zero
        syscall.Umask(0)

        for _, dir := range []string{"proc", "dev", "tmp"} </span><span class="cov0" title="0">{
                if err := os.Mkdir(filepath.Join(chr.location, dir), 0755); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">if err = os.Chmod(filepath.Join(chr.location, "tmp"), 0777); err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "chmod tmp 0777")
        }</span>

        <span class="cov0" title="0">if err := syscall.Mknod(filepath.Join(chr.location, "dev", "/null"),
                syscall.S_IFCHR|0666, makedev(1, 3)); err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "mknod /dev/null")
        }</span>
        <span class="cov0" title="0">if err := syscall.Mknod(filepath.Join(chr.location, "dev", "/random"),
                syscall.S_IFCHR|0666, makedev(1, 8)); err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "mknod /dev/random")
        }</span>
        <span class="cov0" title="0">if err := syscall.Mknod(filepath.Join(chr.location, "dev", "/urandom"),
                syscall.S_IFCHR|0666, makedev(1, 9)); err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "mknod /dev/urandom")
        }</span>

        // mount proc
        <span class="cov0" title="0">if err := syscall.Mount("proc", filepath.Join(chr.location, "proc"), "proc", 0, ""); err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "proc mount")
        }</span>
        <span class="cov0" title="0">for _, mount := range chr.mounts </span><span class="cov0" title="0">{
                src, ro, valid := parseMount(mount)
                if !valid </span><span class="cov0" title="0">{
                        return fmt.Errorf("mount %q is incorrectly formatted, should be like /proc:/proc or /opt:/app:ro", mount)
                }</span>
                <span class="cov0" title="0">srcfi, err := os.Stat(src)
                if err != nil </span><span class="cov0" title="0">{
                        return errors.Wrap(err, "trying to read mount source")
                }</span>
                <span class="cov0" title="0">targetDir := src
                if !srcfi.IsDir() </span><span class="cov0" title="0">{
                        targetDir = filepath.Dir(src)
                }</span>
                <span class="cov0" title="0">if err := os.MkdirAll(filepath.Join(chr.location, targetDir), 0755); err != nil </span><span class="cov0" title="0">{
                        return errors.Wrap(err, "making destination directory")
                }</span>
                <span class="cov0" title="0">target := filepath.Join(chr.location, src)
                if err := syscall.Mount(src, target, "bind", syscall.MS_BIND, ""); err != nil </span><span class="cov0" title="0">{
                        return errors.Wrap(err, "error mounting location: "+src)
                }</span>
                <span class="cov0" title="0">if err := syscall.Mount("none", target, "", syscall.MS_SHARED, ""); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("could not make mount point %s: %w", src, err)
                }</span>
                <span class="cov0" title="0">if ro </span><span class="cov0" title="0">{
                        logger.Debugw("binding readonly")
                        if err := syscall.Mount(src, target, "bind", uintptr(syscall.MS_BIND|syscall.MS_REMOUNT|syscall.MS_RDONLY), ""); err != nil </span><span class="cov0" title="0">{
                                return errors.Wrap(err, "error remounting to readonly")
                        }</span>
                }
        }

        <span class="cov0" title="0">if err := syscall.Chroot(chr.location); err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "chroot")
        }</span>
        <span class="cov0" title="0">chr.chrooted = true

        if err := os.Chdir("/"); err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "chdir")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (chr *chroot) Cleanup() (err error) <span class="cov0" title="0">{
        if !chr.initialized </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">logger.Debugw("cleaning up env", "mounts", chr.mounts)

        root := "/"
        if !chr.chrooted </span><span class="cov0" title="0">{
                root = chr.location
        }</span>
        <span class="cov0" title="0">if err := syscall.Unmount(filepath.Join(root, "proc"), 0); err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "error unmounting proc")
        }</span>

        // must go in reverse order in case we have mounts within mounts
        <span class="cov0" title="0">for i := len(chr.mounts) - 1; i &gt;= 0; i-- </span><span class="cov0" title="0">{
                mount := chr.mounts[i]
                loc, _, _ := parseMount(mount)
                loc = filepath.Join(root, loc)
                logger.Debugw("cleaning up mount", "path", loc)
                if err := syscall.Unmount(loc, 0); err != nil </span><span class="cov0" title="0">{
                        return errors.Wrap(err, "error unmounting location: "+loc)
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">// Ever been to a playground? It's pretty easy to step in and out of a sandbox.
package sandbox

import (
        "context"
        "encoding/json"
        "fmt"
        "io"
        "log"
        "os"
        "os/exec"
        "os/signal"
        "path/filepath"
        "syscall"

        "github.com/creack/pty"
        "github.com/docker/docker/pkg/term"
        "github.com/maxmcd/bramble/pkg/logger"
        "github.com/pkg/errors"
        "golang.org/x/sys/unix"
)

const (
        newNamespaceStepArg = "newNamespace"
        setupStepArg        = "setup"
        execStepArg         = "exec"
        setUIDExecName      = "bramble-setuid"
)

func firstArgMatchesStep() bool <span class="cov0" title="0">{
        switch os.Args[0] </span>{
        case newNamespaceStepArg, setupStepArg, execStepArg:<span class="cov0" title="0">
                return true</span>
        }
        <span class="cov0" title="0">return false</span>
}

// Entrypoint must be run at the beginning of your executable. When the sandbox
// runs it re-runs the same binary with various arguments to indicate that we
// want the process to be run as a sandbox. If this function detects that it
// is needed it will run what it needs and then os.Exit the process, otherwise
// it will be a no-op.
func Entrypoint() <span class="cov0" title="0">{
        if !firstArgMatchesStep() </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">if err := entrypoint(); err != nil </span><span class="cov0" title="0">{
                fmt.Println(err.Error())
                os.Exit(1)
        }</span>
        <span class="cov0" title="0">os.Exit(0)</span>
}

func entrypoint() (err error) <span class="cov0" title="0">{
        if len(os.Args) &lt;= 1 </span><span class="cov0" title="0">{
                return errors.New("unexpected argument count for sandbox step")
        }</span>
        <span class="cov0" title="0">s, err := parseSerializedArg(os.Args[1])
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">switch os.Args[0] </span>{
        case newNamespaceStepArg:<span class="cov0" title="0">
                return s.newNamespaceStep()</span>
        case setupStepArg:<span class="cov0" title="0">
                return s.setupStep()</span>
        case execStepArg:<span class="cov0" title="0">
                s.runExecStep()
                return nil</span>
        default:<span class="cov0" title="0">
                return errors.New("first argument didn't match any known sandbox steps")</span>
        }
}

// Sandbox defines a command or function that you want to run in a sandbox
type Sandbox struct {
        Stdin      io.Reader `json:"-"`
        Stdout     io.Writer `json:"-"`
        Stderr     io.Writer `json:"-"`
        ChrootPath string
        Path       string
        Args       []string
        Dir        string
        Env        []string

        UserID  int
        GroupID int

        // Bind mounts or directories the process should have access too. These
        // should be absolute paths. If a mount is intended to be readonly add
        // ":ro" to the end of the path like `/tmp:ro`
        Mounts []string
        // DisableNetwork will remove network access within the sandbox process
        DisableNetwork bool
        // SetUIDBinary can be used if you want the parent process to call out
        // first to a different binary
        SetUIDBinary string // TODO
}

func (s Sandbox) serializeArg() (string, error) <span class="cov0" title="0">{
        byt, err := json.Marshal(s)
        return string(byt), err
}</span>

func parseSerializedArg(arg string) (s Sandbox, err error) <span class="cov0" title="0">{
        return s, json.Unmarshal([]byte(arg), &amp;s)
}</span>

// Run runs the sandbox until execution has been completed
func (s Sandbox) Run(ctx context.Context) (err error) <span class="cov0" title="0">{
        if term.IsTerminal(os.Stdin.Fd()) </span><span class="cov0" title="0">{
                logger.Debug("is terminal")
        }</span>

        <span class="cov0" title="0">serialized, err := s.serializeArg()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        // TODO: allow reference to self
        <span class="cov0" title="0">path, err := exec.LookPath(setUIDExecName)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">logger.Debugw("newSanbox", "execpath", path)
        // interrupt will be caught be the child process and the process
        // will exiting, causing this process to exit
        ignoreInterrupt()
        cmd := &amp;exec.Cmd{
                Path:   path,
                Args:   []string{newNamespaceStepArg, serialized},
                Stdin:  s.Stdin,
                Stdout: s.Stdout,
                Stderr: s.Stderr,
        }
        errChan := make(chan error)
        go func() </span><span class="cov0" title="0">{
                if err := cmd.Run(); err != nil </span><span class="cov0" title="0">{
                        errChan &lt;- fmt.Errorf("error running newSandbox - %w", err)
                }</span>
                <span class="cov0" title="0">close(errChan)</span>
        }()
        <span class="cov0" title="0">select </span>{
        case &lt;-ctx.Done():<span class="cov0" title="0">
                if cmd.Process != nil </span><span class="cov0" title="0">{
                        if err := cmd.Process.Signal(os.Interrupt); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
                // TODO: do this for all of them? Stop ignoring the interrupt in the children?
        case err = &lt;-errChan:<span class="cov0" title="0">
                if err == nil &amp;&amp; cmd.ProcessState != nil &amp;&amp; cmd.ProcessState.ExitCode() != 0 </span><span class="cov0" title="0">{
                        return errors.New("ah!a")
                }</span>
                <span class="cov0" title="0">return err</span>
        }
        <span class="cov0" title="0">return nil</span> // Start the command with a pty.
}

func (s Sandbox) newNamespaceStep() (err error) <span class="cov0" title="0">{
        selfExe, err := os.Readlink("/proc/self/exe")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                logger.Debugw("clean up chrootDir", "path", s.ChrootPath)
                if er := os.RemoveAll(s.ChrootPath); er != nil </span><span class="cov0" title="0">{
                        logger.Debugw("error cleaning up", "err", er)
                        if err == nil </span><span class="cov0" title="0">{
                                err = errors.Wrap(er, "error removing all files in "+s.ChrootPath)
                        }</span>
                }
        }()
        <span class="cov0" title="0">serialized, err := s.serializeArg()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">var cloneFlags uintptr = syscall.CLONE_NEWUTS |
                syscall.CLONE_NEWNS |
                syscall.CLONE_NEWPID

        if s.DisableNetwork </span><span class="cov0" title="0">{
                cloneFlags |= syscall.CLONE_NEWNET
        }</span>

        // interrupt will be caught be the child process and the process
        // will exiting, causing this process to exit
        <span class="cov0" title="0">ignoreInterrupt()

        cmd := &amp;exec.Cmd{
                Path: selfExe,
                Args: []string{setupStepArg, serialized},
                SysProcAttr: &amp;syscall.SysProcAttr{
                        // maybe sigint will allow the child more time to clean up its mounts????
                        Pdeathsig:  unix.SIGINT,
                        Cloneflags: cloneFlags,
                },
        }

        // We must use a pty here to enable interactive input. If we naively pass
        // os.Stdin to an exec.Cmd then we run into issues with the parent and
        // child terminals getting confused about who is supposed to process various
        // control signals.
        // We can then just set to raw and copy the bytes across. We could remove
        // the pty entirely for jobs that don't pass a terminal as a stdin.
        ptmx, err := pty.Start(cmd)
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "error starting pty")
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{ _ = ptmx.Close() }</span>()

        // only handle stdin and set raw if it's an interactive terminal
        <span class="cov0" title="0">if os.Stdin != nil &amp;&amp; term.IsTerminal(os.Stdin.Fd()) </span><span class="cov0" title="0">{
                // Handle pty resize
                ch := make(chan os.Signal, 1)
                signal.Notify(ch, syscall.SIGWINCH)
                go func() </span><span class="cov0" title="0">{
                        for range ch </span><span class="cov0" title="0">{
                                if err := pty.InheritSize(os.Stdin, ptmx); err != nil </span><span class="cov0" title="0">{
                                        log.Printf("error resizing pty: %s", err)
                                }</span>
                        }
                }()
                <span class="cov0" title="0">ch &lt;- syscall.SIGWINCH // Initial resize.
                oldState, err := term.MakeRaw(os.Stdin.Fd())
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                // restore when complete
                <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{ _ = term.RestoreTerminal(os.Stdin.Fd(), oldState) }</span>()
                <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{ _, _ = io.Copy(ptmx, os.Stdin) }</span>()
        }
        <span class="cov0" title="0">_, _ = io.Copy(os.Stdout, ptmx)
        return errors.Wrap(cmd.Wait(), "error running newNamespace")</span>
}

func (s Sandbox) setupStep() (err error) <span class="cov0" title="0">{
        logger.Debugw("setup chroot", "dir", s.ChrootPath)
        creds := &amp;syscall.Credential{
                Gid: uint32(s.GroupID),
                Uid: uint32(s.UserID),
        }
        if err := os.Chown(s.ChrootPath, int(creds.Uid), int(creds.Gid)); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">chr := newChroot(s.ChrootPath, s.Mounts)
        defer func() </span><span class="cov0" title="0">{
                if er := chr.Cleanup(); er != nil </span><span class="cov0" title="0">{
                        if err == nil </span><span class="cov0" title="0">{
                                err = er
                        }</span> else<span class="cov0" title="0"> {
                                logger.Debugw("error during cleanup", "err", er)
                        }</span>
                }
        }()
        <span class="cov0" title="0">var selfExe string
        </span><span class="cov0" title="0">{
                // hardlink in executable
                selfExe, err = os.Readlink("/proc/self/exe")
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">if err := os.MkdirAll(filepath.Join(s.ChrootPath, filepath.Dir(selfExe)), 0777); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">if err = os.Link(selfExe, filepath.Join(s.ChrootPath, selfExe)); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">if err := chr.Init(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">serialized, err := s.serializeArg()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">cmd := exec.CommandContext(interruptContext(), selfExe)
        cmd.Path = selfExe
        cmd.Args = []string{execStepArg, serialized}
        cmd.Env = append([]string{"USER=bramblebuild0", "HOME=/homeless"}, s.Env...)
        cmd.Stdin = os.Stdin
        cmd.Stdout = os.Stdout
        cmd.Stderr = os.Stderr
        cmd.SysProcAttr = &amp;syscall.SysProcAttr{
                Credential: creds,
        }
        return cmd.Run()</span>
}

func ignoreInterrupt() <span class="cov0" title="0">{
        c := make(chan os.Signal)
        signal.Notify(c, os.Interrupt, syscall.SIGTERM)
        go func() </span><span class="cov0" title="0">{
                for </span><span class="cov0" title="0">{
                        &lt;-c
                }</span>
        }()
}

func interruptContext() context.Context <span class="cov0" title="0">{
        c := make(chan os.Signal)
        signal.Notify(c, os.Interrupt, syscall.SIGTERM)
        ctx, cancel := context.WithCancel(context.Background())
        go func() </span><span class="cov0" title="0">{
                &lt;-c
                cancel()
        }</span>()
        <span class="cov0" title="0">return ctx</span>
}

func (s Sandbox) runExecStep() <span class="cov0" title="0">{
        cmd := exec.Cmd{
                Path: s.Path,
                Dir:  s.Dir,
                Args: append([]string{s.Path}, s.Args...),
                Env:  os.Environ(),

                // We don't use the passed sandbox stdio because
                // it's been passed to the very first run command
                Stdin:  os.Stdin,
                Stdout: os.Stdout,
                Stderr: os.Stderr,
        }
        if err := cmd.Run(); err != nil </span><span class="cov0" title="0">{
                fmt.Println(err.Error())
                os.Exit(1)
        }</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">package starutil

import (
        "github.com/pkg/errors"

        "go.starlark.net/starlark"
)

func IterableToGoList(list starlark.Iterable) (out []string, err error) <span class="cov8" title="1">{
        iterator := list.Iterate()
        defer iterator.Done()
        var val starlark.Value
        for iterator.Next(&amp;val) </span><span class="cov8" title="1">{
                var strValue string
                strValue, err = ValueToString(val)
                if err != nil </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov8" title="1">out = append(out, strValue)</span>
        }
        <span class="cov8" title="1">return</span>
}

func ListToValueList(list *starlark.List) (out []starlark.Value) <span class="cov8" title="1">{
        iterator := list.Iterate()
        defer iterator.Done()
        var val starlark.Value
        for iterator.Next(&amp;val) </span><span class="cov8" title="1">{
                cpy := val
                out = append(out, cpy)
        }</span>
        <span class="cov8" title="1">return</span>
}

func DictToGoStringMap(dict *starlark.Dict) (out map[string]string, err error) <span class="cov8" title="1">{
        out = make(map[string]string)
        for _, key := range dict.Keys() </span><span class="cov8" title="1">{
                envVal, _, _ := dict.Get(key)
                keyString, err := ValueToString(key)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">valString, err := ValueToString(envVal)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">out[keyString] = valString</span>
        }
        <span class="cov8" title="1">return</span>
}

func ValueToString(val starlark.Value) (out string, err error) <span class="cov8" title="1">{
        if val.Type() == "derivation" </span><span class="cov8" title="1">{
                return val.String(), nil
        }</span>
        <span class="cov8" title="1">switch v := val.(type) </span>{
        case starlark.String:<span class="cov8" title="1">
                out = v.GoString()</span>
        case starlark.Int:<span class="cov0" title="0">
                out = v.String()</span>
        case starlark.Bool:<span class="cov0" title="0">
                if v </span><span class="cov0" title="0">{
                        out = "true"
                }</span> else<span class="cov0" title="0"> {
                        out = "false"
                }</span>
        default:<span class="cov0" title="0">
                return "", errors.Errorf("don't know how to cast type %q into a string", v.Type())</span>
        }
        <span class="cov8" title="1">return</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">package starutil

import (
        "bufio"
        "fmt"
        "os"
        "strings"

        "github.com/pkg/errors"
        "go.starlark.net/starlark"
)

type ErrIncorrectType struct {
        shouldBe string
        is       string
}

func (eit ErrIncorrectType) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("incorrect type of %q, should be %q", eit.is, eit.shouldBe)
}</span>

type ErrUnhashable string

func (err ErrUnhashable) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("%s is unhashable", string(err))
}</span>

func AnnotateError(err error) string <span class="cov0" title="0">{
        sb := new(strings.Builder)
        if err, ok := errors.Cause(err).(*starlark.EvalError); ok </span><span class="cov0" title="0">{
                if len(err.CallStack) &gt; 0 &amp;&amp; err.CallStack.At(0).Pos.Filename() == "assert.star" </span><span class="cov0" title="0">{
                        err.CallStack.Pop()
                }</span>
                <span class="cov0" title="0">fmt.Fprintln(sb)
                fmt.Fprintf(sb, "error: %s\n", err.Msg)

                fmt.Fprint(sb, callStackString(err.CallStack))
                return sb.String()</span>
        }
        <span class="cov0" title="0">fmt.Fprintf(sb, "%+v\n", err)
        return sb.String()</span>
}

func callStackString(stack starlark.CallStack) string <span class="cov0" title="0">{
        out := new(strings.Builder)
        fmt.Fprintf(out, "traceback (most recent call last):\n")

        for _, fr := range stack </span><span class="cov0" title="0">{
                fmt.Fprintf(out, "  %s: in %s\n", fr.Pos, fr.Name)
                line := sourceLine(fr.Pos.Filename(), fr.Pos.Line)
                fmt.Fprintf(out, "    %s\n", strings.TrimSpace(line))
        }</span>
        <span class="cov0" title="0">return out.String()</span>
}

func sourceLine(path string, lineNumber int32) string <span class="cov0" title="0">{
        f, err := os.Open(path)
        if err != nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{ _ = f.Close() }</span>()
        <span class="cov0" title="0">var index int32 = 1
        reader := bufio.NewReader(f)
        for </span><span class="cov0" title="0">{
                line, err := reader.ReadString('\n')
                if err != nil </span><span class="cov0" title="0">{
                        return ""
                }</span>
                <span class="cov0" title="0">if index == lineNumber </span><span class="cov0" title="0">{
                        return line
                }</span>
                <span class="cov0" title="0">index++</span>
        }
}
</pre>
		
		<pre class="file" id="file24" style="display: none">package store

import (
        "fmt"
        "io"
        "io/ioutil"
        "os"
        "path/filepath"

        "github.com/maxmcd/bramble/pkg/fileutil"
        "github.com/maxmcd/bramble/pkg/hasher"
        "github.com/pkg/errors"
)

var (
        BuildDirPattern       = "bramble_build_directory*" // TODO: does this ensure the same length always?
        PathPaddingCharacters = "bramble_store_padding"
        PathPaddingLength     = 50

        ErrStoreDoesNotExist = errors.New("calculated store path doesn't exist, did the location change?")
)

func NewStore() (Store, error) <span class="cov8" title="1">{
        s := Store{}
        return s, ensureBramblePath(&amp;s)
}</span>

type Store struct {
        BramblePath string
        StorePath   string
}

func (s Store) IsEmpty() bool <span class="cov8" title="1">{
        return s.BramblePath == "" || s.StorePath == ""
}</span>

func (s Store) TempDir() (tempDir string, err error) <span class="cov8" title="1">{
        tempDir, err = ioutil.TempDir(s.StorePath, BuildDirPattern)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">return tempDir, os.Chmod(tempDir, 0777)</span>
}

func (s Store) TempBuildDir() (tempDir string, err error) <span class="cov0" title="0">{
        return ioutil.TempDir(filepath.Join(s.BramblePath, "var/builds"), "build-")
}</span>

func ensureBramblePath(s *Store) (err error) <span class="cov8" title="1">{
        var exists bool
        // Prefer BRAMBLE_PATH if it's set. Otherwise use the folder "bramble" in
        // the user's home directory.
        s.BramblePath, exists = os.LookupEnv("BRAMBLE_PATH")
        if !exists </span><span class="cov0" title="0">{
                var home string
                home, err = os.UserHomeDir()
                if err != nil </span><span class="cov0" title="0">{
                        return errors.Wrap(err, "error searching for users home directory")
                }</span>
                <span class="cov0" title="0">s.BramblePath = filepath.Join(home, "bramble")</span>
        } else<span class="cov8" title="1"> {
                // Ensure we clean the path so that our padding calculation is consistent.
                s.BramblePath = filepath.Clean(s.BramblePath)
        }</span>

        // No support for relative bramble paths.
        <span class="cov8" title="1">if !filepath.IsAbs(s.BramblePath) </span><span class="cov0" title="0">{
                return errors.Errorf("bramble path %s must be absolute", s.BramblePath)
        }</span>

        <span class="cov8" title="1">if !fileutil.PathExists(s.BramblePath) </span><span class="cov0" title="0">{
                fmt.Println("bramble path directory doesn't exist, creating")
                if err = os.Mkdir(s.BramblePath, 0755); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">fileMap := map[string]struct{}{}
        </span><span class="cov8" title="1">{
                // List all files in the bramble folder.
                files, err := ioutil.ReadDir(s.BramblePath)
                if err != nil </span><span class="cov0" title="0">{
                        return errors.Wrap(err, "error listing files in the BRAMBLE_PATH")
                }</span>
                <span class="cov8" title="1">for _, file := range files </span><span class="cov8" title="1">{
                        fileMap[file.Name()] = struct{}{}
                }</span>

                // Specifically check for files in the var folder.
                <span class="cov8" title="1">files, _ = ioutil.ReadDir(s.JoinBramblePath("var"))
                if len(files) &gt; 0 </span><span class="cov8" title="1">{
                        for _, file := range files </span><span class="cov8" title="1">{
                                fileMap["var/"+file.Name()] = struct{}{}
                        }</span>
                }
        }

        <span class="cov8" title="1">var storeDirectoryName string
        if storeDirectoryName, err = calculatePaddedDirectoryName(s.BramblePath, PathPaddingLength); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">s.StorePath = s.JoinBramblePath(storeDirectoryName)

        // Add store folder with the correct padding and add a convenience symlink
        // in the bramble folder.
        if _, ok := fileMap["store"]; !ok </span><span class="cov8" title="1">{
                if err = os.MkdirAll(s.StorePath, 0755); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">if err = os.Symlink("."+storeDirectoryName, s.JoinBramblePath("store")); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">folders := []string{
                // TODO: move this to a common cache directory or somewhere else that
                // this would be expected to be
                "tmp", // Tmp folder, probably shouldn't exist.

                "var", // The var folder.

                // Metadata for config files to store recently built derivations so that
                // they're not wiped during GC
                "var/config-registry",

                // Cache for starlark file compilation.
                "var/star-cache",

                // Location to mount chroots for builds
                "var/builds",
        }

        for _, folder := range folders </span><span class="cov8" title="1">{
                if _, ok := fileMap[folder]; !ok </span><span class="cov8" title="1">{
                        if err = os.Mkdir(s.JoinBramblePath(folder), 0755); err != nil </span><span class="cov0" title="0">{
                                return errors.Wrap(err, fmt.Sprintf("error creating bramble folder %q", folder))
                        }</span>
                }
        }

        // otherwise, check if the exact store path we need exists
        <span class="cov8" title="1">if _, err = os.Stat(s.StorePath); err != nil </span><span class="cov0" title="0">{
                return ErrStoreDoesNotExist
        }</span>

        <span class="cov8" title="1">return</span>
}

func (s Store) JoinStorePath(v ...string) string <span class="cov8" title="1">{
        return filepath.Join(append([]string{s.StorePath}, v...)...)
}</span>
func (s Store) JoinBramblePath(v ...string) string <span class="cov8" title="1">{
        return filepath.Join(append([]string{s.BramblePath}, v...)...)
}</span>

func (s Store) WriteReader(src io.Reader, name string, validateHash string) (contentHash, path string, err error) <span class="cov8" title="1">{
        hshr := hasher.NewHasher()
        file, err := ioutil.TempFile(s.JoinBramblePath("tmp"), "")
        if err != nil </span><span class="cov0" title="0">{
                err = errors.Wrap(err, "error creating a temporary file for a write to the store")
                return
        }</span>
        <span class="cov8" title="1">tee := io.TeeReader(src, hshr)
        if _, err = io.Copy(file, tee); err != nil </span><span class="cov0" title="0">{
                err = errors.Wrap(err, "error writing to the temporary store file")
                return
        }</span>
        <span class="cov8" title="1">fileName := hshr.String()
        if validateHash != "" &amp;&amp; hshr.Sha256Hex() != validateHash </span><span class="cov0" title="0">{
                return hshr.Sha256Hex(), "", hasher.ErrHashMismatch
        }</span>
        <span class="cov8" title="1">if name != "" </span><span class="cov8" title="1">{
                fileName += ("-" + name)
        }</span>
        <span class="cov8" title="1">path = s.JoinStorePath(fileName)
        if err = file.Close(); err != nil </span><span class="cov0" title="0">{
                return "", "", err
        }</span>
        <span class="cov8" title="1">if er := os.Rename(file.Name(), path); er != nil </span><span class="cov0" title="0">{
                return "", "", errors.Wrap(er, "error moving file into store")
        }</span>
        <span class="cov8" title="1">if err = os.Chmod(path, 0444); err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">return hshr.Sha256Hex(), path, nil</span>
}

func (s Store) WriteConfigLink(location string) (err error) <span class="cov8" title="1">{
        hshr := hasher.NewHasher()
        if _, err = hshr.Write([]byte(location)); err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">reg := s.JoinBramblePath("var/config-registry")
        hash := hshr.String()
        configFileLocation := filepath.Join(reg, hash)
        return ioutil.WriteFile(configFileLocation, []byte(location), 0644)</span>
}

func calculatePaddedDirectoryName(bramblePath string, paddingLength int) (storeDirectoryName string, err error) <span class="cov8" title="1">{
        paddingLen := paddingLength -
                len(bramblePath) - // parent folder lengths
                1 - // slash before directory
                1 // slash after the directory

        if paddingLen &lt;= 0 </span><span class="cov0" title="0">{
                return "", errors.Errorf(
                        "Bramble location creates a path that is too long. "+
                                "Location '%s' is too long to create a directory less than %d in length",
                        bramblePath, paddingLen)
        }</span>

        <span class="cov8" title="1">paddingSize := len(PathPaddingCharacters)
        repetitions := paddingLen / (paddingSize + 1)
        extra := paddingLen % (paddingSize + 1)

        for i := 0; i &lt; repetitions; i++ </span><span class="cov0" title="0">{
                storeDirectoryName += ("/" + PathPaddingCharacters)
        }</span>
        <span class="cov8" title="1">storeDirectoryName += ("/" + PathPaddingCharacters[:extra])
        return storeDirectoryName, nil</span>
}
</pre>
		
		<pre class="file" id="file25" style="display: none">package textreplace

import (
        "bytes"
        "errors"
        "io"
        "strings"
)

var (
        ErrNotSameLength = errors.New("old and new prefixes must be the same length")
)

// ReplaceStringsPrefix replaces the prefix of matching strings in a byte
// stream. All values to be replaced must have the same prefix and that
// prefix must be the same length as the new value.
func ReplaceStringsPrefix(source io.Reader, output io.Writer, values []string, old string, new string) (
        replacements int, matches map[string]struct{}, err error) <span class="cov8" title="1">{
        if len(old) != len(new) </span><span class="cov0" title="0">{
                return 0, nil, ErrNotSameLength
        }</span>
        <span class="cov8" title="1">longestValueLength := 0
        for _, in := range values </span><span class="cov8" title="1">{
                if len(in) &gt; longestValueLength </span><span class="cov8" title="1">{
                        longestValueLength = len(in)
                }</span>
        }

        <span class="cov8" title="1">matches = make(map[string]struct{})
        _, err = CopyWithFrames(source, output, nil, longestValueLength, func(b []byte) error </span><span class="cov8" title="1">{
                j := 0
                for </span><span class="cov8" title="1">{
                </span>BEGIN:
                        <span class="cov8" title="1">i := bytes.Index(b[j:], []byte(old))
                        if i &lt; 0 </span><span class="cov8" title="1">{
                                break</span>
                        }
                        <span class="cov8" title="1">j += i
                        // Could use a trie here if the values list is very long.
                        for _, input := range values </span><span class="cov8" title="1">{
                                // if the input is longer than the remaining buffer length continue
                                if len(input) &gt; len(b[j:]) </span><span class="cov0" title="0">{
                                        continue</span>
                                }
                                <span class="cov8" title="1">if string(b[j:j+len(input)]) == input </span><span class="cov8" title="1">{
                                        matches[string(input)] = struct{}{}
                                        replacements++
                                        copy(b[j:j+len(old)], new)
                                        goto BEGIN</span>
                                }
                        }
                        <span class="cov0" title="0">break</span>
                }
                <span class="cov8" title="1">return nil</span>
        })
        <span class="cov8" title="1">return</span>
}

// replaceStringsPrefixReplacer uses the strings.Replacer to replace the
// values, currently just used as a benchmark comparison
func replaceStringsPrefixReplacer(source io.Reader, output io.Writer, values []string, old string, new string) (
        err error) <span class="cov0" title="0">{
        if len(old) != len(new) </span><span class="cov0" title="0">{
                return ErrNotSameLength
        }</span>
        <span class="cov0" title="0">longestValueLength := 0
        for _, in := range values </span><span class="cov0" title="0">{
                if len(in) &gt; longestValueLength </span><span class="cov0" title="0">{
                        longestValueLength = len(in)
                }</span>
        }
        <span class="cov0" title="0">reps := []string{}
        for _, v := range values </span><span class="cov0" title="0">{
                reps = append(reps, old+v, new+v)
        }</span>
        <span class="cov0" title="0">replacer := strings.NewReplacer(reps...)
        _, err = CopyWithFrames(source, output, nil, longestValueLength, func(b []byte) error </span><span class="cov0" title="0">{
                c := replacer.Replace(string(b))
                copy(b, c)
                return nil
        }</span>)
        <span class="cov0" title="0">return</span>
}

// CopyWithFrames copies data between two sources. As data is copied it is
// loaded into a byte buffer that overlaps with the previous buffer. This
// ensures that bytes of a certain width will not be split over the boundary
// of a frame.
func CopyWithFrames(src io.Reader, dst io.Writer, buf []byte, overlapSize int, transform func(b []byte) error) (
        written int64, err error) <span class="cov8" title="1">{
        if buf == nil </span><span class="cov8" title="1">{
                size := 32 * 1024 // The default from io/io.go.
                buf = make([]byte, size)
        }</span>
        <span class="cov8" title="1">firstPassOffset := overlapSize
        for </span><span class="cov8" title="1">{
                nr, er := src.Read(buf[overlapSize:])
                // TODO: if our first read is less than the length of the frame, what
                // do we do about that?
                // TODO: set up tests with many variable first read sizes
                if nr &gt; 0 </span><span class="cov8" title="1">{
                        if err = transform(buf[firstPassOffset:]); err != nil </span><span class="cov0" title="0">{
                                return
                        }</span>
                        <span class="cov8" title="1">nw, ew := dst.Write(buf[firstPassOffset:nr])
                        if nw &gt; 0 </span><span class="cov8" title="1">{
                                written += int64(nw)
                        }</span>
                        <span class="cov8" title="1">if ew != nil </span><span class="cov0" title="0">{
                                err = ew
                                break</span>
                        }
                        // We write a subset of the read bytes on the first pass so
                        // we
                        <span class="cov8" title="1">if nr != nw &amp;&amp; written != int64(nr-firstPassOffset) </span><span class="cov0" title="0">{
                                err = io.ErrShortWrite
                                break</span>
                        }
                        <span class="cov8" title="1">if n := copy(buf[:overlapSize], buf[nr:nr+overlapSize]); n != overlapSize </span><span class="cov0" title="0">{
                                panic(overlapSize)</span>
                        }
                } else<span class="cov8" title="1"> if er != nil </span><span class="cov8" title="1">{
                        if er != io.EOF </span><span class="cov0" title="0">{
                                err = er
                        }</span>
                        <span class="cov8" title="1">nw, ew := dst.Write(buf[:overlapSize])
                        if ew != nil </span><span class="cov0" title="0">{
                                err = ew
                        }</span>
                        <span class="cov8" title="1">written += int64(nw)
                        break</span>
                } else<span class="cov8" title="1"> {
                        // if we have read 0 and there is no error just go back and read again
                        continue</span>
                }
                <span class="cov8" title="1">firstPassOffset = 0</span>
        }
        <span class="cov8" title="1">return</span>
}

func replaceBytesReplace(src io.Reader, dst io.Writer, old []byte, new []byte) (written int64, err error) <span class="cov0" title="0">{
        if len(old) != len(new) </span><span class="cov0" title="0">{
                return 0, ErrNotSameLength
        }</span>
        <span class="cov0" title="0">return CopyWithFrames(src, dst, nil, len(old), func(b []byte) error </span><span class="cov0" title="0">{
                copy(b, bytes.ReplaceAll(b, old, new))
                return nil
        }</span>)
}

func ReplaceBytes(src io.Reader, dst io.Writer, old []byte, new []byte) (written int64, err error) <span class="cov8" title="1">{
        if len(old) != len(new) </span><span class="cov0" title="0">{
                return 0, ErrNotSameLength
        }</span>
        <span class="cov8" title="1">return CopyWithFrames(src, dst, nil, len(old), func(b []byte) error </span><span class="cov8" title="1">{
                return InPlaceReplaceAll(b, old, new)
        }</span>)
}

func InPlaceReplaceAll(s, old, new []byte) (err error) <span class="cov8" title="1">{
        return InPlaceReplace(s, old, new, -1)
}</span>

func InPlaceReplace(s, old, new []byte, n int) (err error) <span class="cov8" title="1">{
        if len(old) != len(new) </span><span class="cov0" title="0">{
                return ErrNotSameLength
        }</span>

        <span class="cov8" title="1">m := 0
        if n != 0 </span><span class="cov8" title="1">{
                // Compute number of replacements.
                m = bytes.Count(s, old)
        }</span>
        <span class="cov8" title="1">if m == 0 </span><span class="cov8" title="1">{
                // return unchanged
                return
        }</span>
        <span class="cov0" title="0">if n &lt; 0 || m &lt; n </span><span class="cov0" title="0">{
                n = m
        }</span>

        <span class="cov0" title="0">start := 0
        for i := 0; i &lt; n; i++ </span><span class="cov0" title="0">{
                j := start
                j += bytes.Index(s[start:], old)
                copy(s[j:j+len(old)], new)
                start = j + len(old)
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
